<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #555; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #555, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #555;    /*上边框颜色*/
        border-left-color: #555;    /*左边框颜色*/
    }
</style>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="kotlin,基础," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1" />






<meta name="description" content="基本要素：函数和变量打印经典的 &amp;quot;Hello, world!&amp;quot; 的 Kotlin 代码如下： fun main(args: Array&amp;lt;String&amp;gt;) {     println(&amp;quot;Hello,world!&amp;quot;) } 相应的 Java 代码实现如下： public static void main(String[] args) {     Sys">
<meta name="keywords" content="kotlin,基础">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin基础">
<meta property="og:url" content="http://yoursite.com/2019/09/26/kotlin/KotlinBase/index.html">
<meta property="og:site_name" content="FandaCode">
<meta property="og:description" content="基本要素：函数和变量打印经典的 &amp;quot;Hello, world!&amp;quot; 的 Kotlin 代码如下： fun main(args: Array&amp;lt;String&amp;gt;) {     println(&amp;quot;Hello,world!&amp;quot;) } 相应的 Java 代码实现如下： public static void main(String[] args) {     Sys">
<meta property="og:updated_time" content="2019-10-10T07:34:40.258Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin基础">
<meta name="twitter:description" content="基本要素：函数和变量打印经典的 &amp;quot;Hello, world!&amp;quot; 的 Kotlin 代码如下： fun main(args: Array&amp;lt;String&amp;gt;) {     println(&amp;quot;Hello,world!&amp;quot;) } 相应的 Java 代码实现如下： public static void main(String[] args) {     Sys">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/26/kotlin/KotlinBase/"/>





     <title> Kotlin基础 | FandaCode </title>
</head>




<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  
  
  <div class="bg_content">
    <div class="filter"></div>
    <canvas id="canvas"></canvas>
  </div>
 <script src="js/src/jquery.min.js"></script>
  
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
	<a href="https://github.com/fandazeng" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a>    
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FandaCode</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">IT相关技术</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user-circle-o"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>
	

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/kotlin/KotlinBase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fanda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FandaCode">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Kotlin基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-26T09:47:44+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">kotlin</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kotlin/基础/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/09/26/kotlin/KotlinBase/" class="leancloud_visitors" data-flag-title="Kotlin基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="基本要素：函数和变量"><a href="#基本要素：函数和变量" class="headerlink" title="基本要素：函数和变量"></a>基本要素：函数和变量</h2><p>打印经典的 <code>&quot;Hello, world!&quot;</code> 的 <code>Kotlin</code> 代码如下：</p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    println(&quot;Hello,world!&quot;)
}
</code></pre><p>相应的 <code>Java</code> 代码实现如下：</p>
<pre><code>public static void main(String[] args) {
    System.out.println(&quot;Hello,world!&quot;);
}
</code></pre><p>对比可观察到 <code>Kotlin</code> 的特性如下：</p>
<ul>
<li>用 <code>fun</code> 来声明一个函数。</li>
<li>参数的类型写在参数名称后面，用冒号分隔。</li>
<li>数组是一个类，没有 <code>Java</code> 中声明数组类型的语法。</li>
<li>使用 <code>println</code> 代替了 <code>System.out.println</code> ，这是 <code>Kotlin</code> 标准库给 <code>Java</code> 标准库提供了许多语法更简洁的包装，<code>println</code> 方法是其中之一。</li>
<li>代码结尾省略分号。</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>带返回值的函数示例如下：</p>
<pre><code>fun max(a: Int, b: Int): Int {
    return if (a &gt; b) a else b
}
</code></pre><p>相应的 <code>Java</code> 代码实现如下：</p>
<pre><code>public static final int max(int a, int b) {
      return a &gt; b ? a : b;
}
</code></pre><p>函数声明总结：</p>
<pre><code>fun —— 函数名 —— (参数列表) —— 冒号 —— 返回类型
</code></pre><p>对应上述方法如下:</p>
<pre><code>fun —— max —— (a: Int, b: Int) —— : —— Int
</code></pre><p>上述函数说明了在 <code>kotlin</code> 中， <code>if</code> 是有结果值的表达式，类似于 <code>Java</code> 中的三元运算符(kotlin 里没有三元运算符)。</p>
<h3 id="语句和表达式的区别"><a href="#语句和表达式的区别" class="headerlink" title="语句和表达式的区别"></a>语句和表达式的区别</h3><p><code>kotlin</code> 中 ， <code>if</code> 是表达式而不是语句，表达式有值，并且能作为另一个表达式的一部分使用；而语句总是包围它的代码块中的顶层元素，并且没有自己的值。在 <code>Java</code> 中，所有的控制结构都是语句，而在 <code>kotlin</code> 中，除了循环(for、 while、 do/while)以外大多数控制结构都是表达式。</p>
<p><strong>注意： <code>Java</code> 中赋值操作是表达式，而 <code>Kotlin</code> 中反而变成了语句，这有助于避免比较和赋值操作之间的混淆。</strong></p>
<p>代码示例如下：</p>
<pre><code>//kotlin，此方法不能编译，赋值是语句，没有值，不能直接返回
fun assignment(a: Int): Int {
    return  a = 100
}

//java ，正常编译，赋值是表达式，有值，能直接返回
public static int assignment(int a) {
    return a = 100;
}
</code></pre><h3 id="表达式函数体"><a href="#表达式函数体" class="headerlink" title="表达式函数体"></a>表达式函数体</h3><p>如果函数体是由单个表达式构成，可以去掉花括号和 <code>return</code> 语句，并且可以省略返回类型，称之为表达式函数体，否则称之为代码块函数体。把上述带返回值的函数变成表达式体后的代码如下：</p>
<pre><code>// 表达式体的方式展示
fun maxExpression(a:Int,b: Int) = if (a &gt; b) a else b
</code></pre><h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>事实上，每个变量和表达式都有类型，每个函数都有返回类型，但是对表达式体函数来说，编译器会分析该表达式并把它的类型作为函数的返回类型，即使没有显式地写出来，这被称作<strong>类型推导</strong>。</p>
<p><strong>注意：只有表达式体函数可以省略返回类型和 <code>return</code> 语句，代码块体函数不能省略返回类型和 <code>return</code> 语句。</strong></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在 <code>Kotlin</code> 中变量声明以关键字开始，然后是变量名称，最后加上类型(类型也可以省略)。</p>
<p><code>kotlin</code> 代码：</p>
<pre><code>// 显式指定变量类型
val question: String = &quot;Are you Ok ?&quot;
// 通过类型推导
val answer = &quot;yes&quot;

// val 是关键字 ，answer 是变量名称，String 是类型
</code></pre><p><code>java</code> 代码：</p>
<pre><code>final String question = &quot;Are you Ok ?&quot;;
final String answer = &quot;yes&quot;;
</code></pre><p><strong>注意： 如果不能提供赋值给这个变量的信息，编译器则无法推导出它的类型，需要显式地指定它的类型。</strong></p>
<h3 id="可变变量和不可变变量"><a href="#可变变量和不可变变量" class="headerlink" title="可变变量和不可变变量"></a>可变变量和不可变变量</h3><p>声明变量的关键字有两个：</p>
<ul>
<li><p><code>val</code> (来自 value)，不可变引用，在初始化之后不能再次赋值，对应 <code>Java</code> 中的 <code>final</code> 变量。</p>
</li>
<li><p><code>var</code> (来自 variable)，可变引用，可以再次赋值，对应 <code>Java</code> 中非 <code>final</code> 变量。</p>
</li>
</ul>
<p>如果编译器能确保只有唯一一条初始化语句会被执行，可以根据条件使用不同的值来初始化它。示例如下：</p>
<pre><code>class Variable {
    // 需要显式指定类型
    val otherAnswer: String

    constructor(cotent: String) {
        // 在构造方法中赋值
        otherAnswer = if (cotent.isEmpty()) &quot;no&quot; else &quot;yes&quot;
    }
}
</code></pre><p><strong>注意：尽管 <code>val</code> 引用自身是不可变的，但是它指向的对象可能是可变的</strong>，例如：</p>
<pre><code>// val 引用的对象可能是可变的
val languages = arrayListOf(&quot;kotlin&quot;, &quot;java&quot;)
languages.add(&quot;python&quot;)
</code></pre><p>其实和 <code>Java</code> 一致， <code>final</code> 定义一个集合，集合中的数据是可以改变的，引用不变即可。</p>
<p><strong>注意： var 声明的变量允许改变值，但不能改变类型</strong>，例如：</p>
<pre><code>var answer = &quot;yes&quot;
// 不能编译 The integer literal does not conform to the expected type String
answer = 100
</code></pre><p><code>answer</code> 通过类型推导已经知道是 <code>String</code> 类型了，后续的赋值操作不能改变类型。</p>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p><code>Kotlin</code> 允许在字符串字面值中引用局部变量，只需要在变量名称前面加上字符 <code>$</code>，当然表达式会进行静态检查，引用不存在的变量时代码根本不能编译，示例如下：</p>
<pre><code>val content = &quot;test&quot;
val age = 18

println(&quot;打印的内容如下： $content&quot;)
println(&quot;年纪为：${age}岁&quot;)
</code></pre><p><code>Java</code> 代码如下：</p>
<pre><code>String var = &quot;打印的内容如下： &quot; + content;
String var2 = &quot;年纪为：&quot; + age + &apos;岁&apos;;
</code></pre><p><strong>注意： 引用字符串变量时，可省略 <code>{}</code> ，其它变量不能省略。如果要在字符串中使用 <code>$</code> 符号，需要对它进行转义(在 $ 前加上 ‘\’ 即可)</strong>，示例如下：</p>
<pre><code>// 输出 转义：$test
print(&quot;转义：\$$content&quot;)
</code></pre><p>通过使用 <code>${}</code> 的方式可以引用更复杂的表达式：</p>
<pre><code>// 输出 1 + 2 = 3
println(&quot;1 + 2 = ${1 + 2}&quot;)
</code></pre><p>还可以在双引号内嵌套双引号，只要它们在 <code>{}</code> 内：</p>
<pre><code>// 输出 age大于10 
println(&quot;age${if (age &gt; 10) &quot;大于10&quot; else &quot;小于10&quot;}&quot;)
</code></pre><h2 id="类和属性"><a href="#类和属性" class="headerlink" title="类和属性"></a>类和属性</h2><p>先来看一个简单的 <code>JavaBean</code> 类 <code>Person</code> ，它只有一个属性 <code>name</code> 。</p>
<pre><code>public class Person {
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
</code></pre><p>在 <code>Java</code> 中，构造方法的方法体常常包含完全重复的代码：它把参数赋值给有着相同名称的字段。在 <code>Kotlin</code> 中，这种逻辑不用这么多的样板代码就可以表达。 使用 <code>Convert Java File To Kotlin File</code> 将这个对象转换成 <code>Kotlin</code>：</p>
<pre><code>class Person(val name: String)
</code></pre><p>没错，就是只有一行代码。这种只有数据没有其他代码的类通常被叫做<strong>值对象</strong>。</p>
<p><strong>注意： 在 kotlin 中 public 是默认的可见性，所以可以省略它。</strong></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>在 <code>Java</code> 中 ，字段和其访问器(setter/getter) 的组合被叫作属性。在 <code>Kotlin</code> 中，属性是头等语言特性，完全代替了字段和访问器方法，声明一个属性和声明一个变量一样，用 <code>val</code> 和 <code>var</code> 关键字，声明成 <code>val</code> 的属性是只读的，而 <code>var</code> 属性是可变的。</p>
<pre><code>class Person{
    // 只读属性，生成一个字段和一个简单的 getter
    val name : String    
    // 可变属性，生成一个字段、一个简单的 getter 和一个简单的 setter
    var isMarried : Boolean

    // 构造方法
    constructor(_name: String , _isMarried : Boolean){
        name = _name
        isMarried = _isMarried
    }

}
</code></pre><p>将上述的 <code>Person</code> 转换成 <code>Java</code> 实现如下：</p>
<pre><code>public final class Person {
   @NotNull
   private final String name;
   private boolean isMarried;

   @NotNull
   public final String getName() {
      return this.name;
   }

   public final boolean isMarried() {
      return this.isMarried;
   }

   public final void setMarried(boolean var1) {
      this.isMarried = var1;
   }

   public Person(@NotNull String _name, boolean _isMarried) {
      Intrinsics.checkParameterIsNotNull(_name, &quot;_name&quot;);
      super();
      this.name = _name;
      this.isMarried = _isMarried;
   }
}
</code></pre><p>简单的说就是平时我们用代码模板生成的 <code>bean</code> ，在 <code>Kotlin</code> 中连模板都不需要使用了，编译时会自动生成对应的代码。生成的 <code>getter</code> 和 <code>setter</code> 方法都是在属性名称前加上 <code>get</code> 和 <code>set</code> 前缀作为方法名，但是有一种例外，如果属性时以 <code>is</code> 开头，<code>getter</code> 不会增加前缀，而它的 <code>setter</code> 名称中 <code>is</code> 会被替换成 <code>set</code> 。所以你调用的将是 <code>isMarried()</code> 。</p>
<p>在 <code>Java</code> 中使用是这样的：</p>
<pre><code>// 跟用 Java 生成的类的使用方式一样
Person person = new Person(&quot;fanda&quot;, true);
System.out.println(person.getName());
System.out.println(person.isMarried());
</code></pre><p>在 <code>kotlin</code> 中使用是这样的：</p>
<pre><code>// 不需要关键字 new 
val person = Person(&quot;fanda&quot;, true)
// 可以直接访问属性，底层调用还是访问器
println(person.name)
println(person.isMarried)
</code></pre><p><code>Java</code> 类在 <code>kotlin</code> 中也可以使用这样简洁的语法来使用，会相应地转化为对应的 <code>val</code> 属性和 <code>var</code> 属性。</p>
<h3 id="自定义访问器"><a href="#自定义访问器" class="headerlink" title="自定义访问器"></a>自定义访问器</h3><p>接下来声明一个矩形，它能判断自己是否是正方形，不需要一个单独的字段来存储这个信息，因为可以随时检查矩形的长宽是否相等来判断：</p>
<pre><code>class Rectangle(val height: Int, val width: Int) {

    val isSquare: Boolean
        // 自定义 getter 访问器，这里使用了表达体函数
        get() = height == width
}
</code></pre><p>相应的 <code>Java</code> 代码如下：</p>
<pre><code>public final class Rectangle {
   private final int height;
   private final int width;

   public final boolean isSquare() {
      return this.height == this.width;
   }

   public final int getHeight() {
      return this.height;
   }

   public final int getWidth() {
      return this.width;
   }

   public Rectangle(int height, int width) {
      this.height = height;
      this.width = width;
   }
}
</code></pre><p>注意： 这里的 <code>isSquare</code> 在转化为 <code>Java</code> 代码时，就是一个无参的函数，其实也可以直接在 <code>kotlin</code> 中定义同样的函数，没有任何差别。通常来说，如果描述的是类的特征(属性)，应该把它声明成属性。</p>
<h3 id="Kotlin-源码布局：目录和包"><a href="#Kotlin-源码布局：目录和包" class="headerlink" title="Kotlin 源码布局：目录和包"></a>Kotlin 源码布局：目录和包</h3><p>与 <code>Java</code> 类似，每一个 <code>Kotlin</code> 文件都能以一条 <code>package</code> 语句开头，而文件中定义的所有声明（类、函数及属性）都会被放到这个包中。<strong>如果其他文件中定义的声明也有相同的包，这个文件可以直接使用它们</strong>；如果包不相同，则需要导入它们。和 <code>Java</code> 一样，导入语句放在文件的最前面并使用关键字 <code>import</code> ，仅仅省略了分号。</p>
<pre><code>package zeng.fanda.com.kotlinpratice.base

import kotlin.random.Random
</code></pre><p>注意： <strong><code>Kotlin</code> 不区分导入的是类还是函数，可以直接导入顶层函数的名称</strong>，在 <code>Kotlin</code> 中的函数可以单独存在，不一定要在类中声明，可以直接声明在文件中，这种函数叫做顶层函数，如果声明的是属性，就叫做顶层属性，无论是顶层函数还是属性，都可以直接导入使用。</p>
<p>在 <code>Java</code> 中，要把类放在和包结构相匹配的文件与目录结构中。而在 <code>Kotlin</code> 中包层级机构不需要遵循目录层级结构，可以把多个类放进同一个文件中。但是不管怎样，遵循 <code>Java</code> 的目录布局更根据包结构把源码文件放到对应的目录中是个更好的选择，避免一些不期而遇的错误。</p>
<h2 id="表示和处理选择：枚举和-“when”"><a href="#表示和处理选择：枚举和-“when”" class="headerlink" title="表示和处理选择：枚举和 “when”"></a>表示和处理选择：枚举和 “when”</h2><h3 id="声明枚举类"><a href="#声明枚举类" class="headerlink" title="声明枚举类"></a>声明枚举类</h3><p><code>Kotlin</code> 中声明枚举类如下：</p>
<pre><code>enum class Color {
    RED, GREEN, BLUE
}
</code></pre><p>通过 <code>enum</code> 和 <code>class</code> 两个关键字来声明一个枚举类(在 Java 中只需要 enum)，<code>enum</code> 是一个软关键字，只有和 <code>class</code> 连用才有效，在其他地方可当普通名称使用，和 <code>Java</code> 一样，枚举不是值的列表，可以给枚举类声明属性和方法：</p>
<pre><code>// 声明带属性和方法的枚举类
enum class Color(val r: Int, val g: Int, val b: Int) {
    RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255) ;// 这里必须要有分号，用于分隔枚举常量和方法

    // 给枚举类定义一个方法
    fun rgb() = (r * 256 + g) * 256 + b

}
</code></pre><p>相应的 <code>Java</code> 代码如下：</p>
<pre><code>public enum Color {
   RED,
   GREEN,
   BLUE;

   private final int r;
   private final int g;
   private final int b;

   public final int rgb() {
      return (this.r * 256 + this.g) * 256 + this.b;
   }

   public final int getR() {
      return this.r;
   }

   public final int getG() {
      return this.g;
   }

   public final int getB() {
      return this.b;
   }

   private Color(int r, int g, int b) {
      this.r = r;
      this.g = g;
      this.b = b;
   }
}
</code></pre><p>枚举常量用的声明构造方法和属性的语法一样，而必须提供该常量的属性值，这里展示了 <code>Kotlin</code> 中唯一使用分号的情况，如果要在枚举类中定义任何方法，必须用分号将常量列表和方法分开。</p>
<h3 id="使用-“when”-处理枚举类"><a href="#使用-“when”-处理枚举类" class="headerlink" title="使用 “when” 处理枚举类"></a>使用 “when” 处理枚举类</h3><p>对于 <code>Java</code> ，通常使用 <code>switch</code> 来匹配枚举，如下：</p>
<pre><code>public static String getColorStr(Color color) {
    String colorStr;
    switch (color) {
        case RED:
            colorStr = &quot;red&quot;;
            break;
        case GREEN:
            colorStr = &quot;green&quot;;
            break;
        case BLUE:
            colorStr = &quot;blue&quot;;
            break;
        default:
            colorStr = &quot;nothing&quot;;
            break;
    }
    return colorStr;
}
</code></pre><p>在 <code>kotlin</code> 中是没有 <code>switch</code> 语句的，而是用 <code>when</code> 表达式来处理，注意这是一个有返回值的表达式，因此可以用表达式体函数来直接返回一个 <code>when</code> 表达式：</p>
<pre><code>fun getColorStr(color: Color) =
    when (color) {
        Color.RED -&gt; &quot;red&quot;
        Color.GREEN -&gt; &quot;green&quot;
        Color.BLUE -&gt; &quot;blue&quot;
        else -&gt; &quot;nothing&quot;
    }
</code></pre><p>相比来说，<code>kotlin</code> 的代码相当简洁，不需要在每个分支都写 <code>break</code> 语句，如果匹配成功，只有对应的分支会执行，也可以把多个值合并到同一个分支，只需要用逗号隔开，如下：</p>
<pre><code>fun getColor(color: Color) = when (color) {
    Color.BLUE, Color.GREEN -&gt; &quot;bule and green&quot;
    Color.RED -&gt; &quot;red&quot;
}
</code></pre><p>还可以通过导入这些枚举常量来简化代码：</p>
<pre><code>import zeng.fanda.com.kotlinpratice.base.Color.*

fun getColorStr(color: Color) =
    when (color) {
        RED -&gt; &quot;red&quot;
        GREEN -&gt; &quot;green&quot;
        BLUE -&gt; &quot;blue&quot;
        else -&gt; &quot;nothing&quot;
    }

fun getColor(color: Color) = when (color) {
    BLUE, GREEN -&gt; &quot;bule and green&quot;
    RED -&gt; &quot;red&quot;
}
</code></pre><h3 id="在-“when”-结构中使用任意对象"><a href="#在-“when”-结构中使用任意对象" class="headerlink" title="在 “when” 结构中使用任意对象"></a>在 “when” 结构中使用任意对象</h3><p><code>when</code> 比 <code>switch</code> 强大的多，<code>switch</code> 要求必须使用常量(枚举常量、字符串或数字字面值)作为分支条件，<code>when</code> 允许使用任何对象，接下来写一个混合两种颜色的函数来体验一下这种特性：</p>
<pre><code>fun mix(c1: Color, c2: Color) =
    when (setOf(c1, c2)) {
        setOf(RED,GREEN) -&gt; BLUE
        setOf(RED,BLUE) -&gt; GREEN
        else -&gt; throw Exception(&quot;nothing&quot;)
    }
</code></pre><p><code>setOf</code> 是 <code>kotlin</code> 标准库提供的一个方法，用于创建 <code>Set</code> (无序)集合，如果没有其他的分支满足条件，<code>else</code> 分支会被执行。</p>
<h3 id="使用不带参数的-“when”"><a href="#使用不带参数的-“when”" class="headerlink" title="使用不带参数的 “when”"></a>使用不带参数的 “when”</h3><p>上面的函数每次调用时都会创建一些 <code>Set</code> 实例，如果该函数调用很频繁，为了避免创建额外的垃圾对象，可以用如下方法来重构，虽然可读性会变差：</p>
<pre><code>fun mixOptimized(c1: Color, c2: Color) =
    when {
        (c1 == RED &amp;&amp; c2 == GREEN) || (c1 == GREEN &amp;&amp; c2 == RED) -&gt; BLUE
        (c1 == RED &amp;&amp; c2 == BLUE) || (c1 == BLUE &amp;&amp; c2 == RED) -&gt; GREEN
        else -&gt; throw Exception(&quot;nothing&quot;)
    }
</code></pre><p><strong>如果没有给 when 表达式提供参数，分支条件就是任意的布尔表达式。</strong></p>
<h3 id="智能转换"><a href="#智能转换" class="headerlink" title="智能转换"></a>智能转换</h3><p>在 <code>Java</code> 中存在多态的概念，当用父类和接口类声明一个对象时，可以创建其子类或实现类，当需要用到子类或实现类时，需要对其进行实例判断并显式地对其进行类型强转，而在 <code>Kotlin</code> 中，当已经进行实例判断之后，不再需要显式强转操作了，编译器会帮助执行类型转换，这种行为称为<strong>智能转换</strong>，下面看一下示例：</p>
<p><code>Kotlin</code> 代码如下：</p>
<pre><code>// 一个基类接口
interface Expr

// 简单的值对象，实现 Expr 接口
class Num(val value: Int) : Expr

// Sum 运算，需要左右两个简单值对象，运用多态，声明成基类
class Sum(val left: Expr, val right: Expr) : Expr

// 如果表达式是 Num 类型，直接返回值，如果是 Sum 类型，先计算左右表达式的值再求和
fun eval(e: Expr): Int =
    when (e) {
        // 用 is 判断实例，不需要再强转
        is Num -&gt; e.value
        is Sum -&gt; eval(e.left)+ eval(e.right)
        else -&gt; throw Exception(&quot;error&quot;)
    }
</code></pre><p><code>Java</code> 代码如下(只显示 eval 方法)：</p>
<pre><code>public static final int eval(Expr e) throws Exception {
    int result;
    if (e instanceof Num) {
        result = ((Num) e).getValue();
    } else {
        // 用 instanceof 判断实例
        if (!(e instanceof Sum)) {
            throw new Exception(&quot;error&quot;);
        }
        // 需要强制转换
        result = eval(((Sum) e).getLeft()) + eval(((Sum) e).getRight());
    }
    return result;
}
</code></pre><p>对比两者代码，用 <code>kotlin</code> 的方式实现非常的简洁，<code>is</code> 检查类似于 <code>instanceof</code> ，而且检查过之后不再需要强转指定类型，这里再次展示了 <code>when</code> 作为有返回值的表达式的好处，不需要用 <code>result</code> 来做临时的变量来做返回。同时这里也展示了用 <code>when</code> 来代替 <code>if</code> 做多个条件判断的简洁性，如果分支条件较少，可以用 <code>if</code> ，否则用 <code>when</code> 更有优势。</p>
<p><strong>注意：如果需要显式的强转操作，需要用到 <code>as</code> 关键字</strong>，如下：</p>
<pre><code>// 把 e 强转为 Num 类型赋值给 n
val n = e as Num
</code></pre><h3 id="代码块作为-“when”-的分支"><a href="#代码块作为-“when”-的分支" class="headerlink" title="代码块作为 “when” 的分支"></a>代码块作为 “when” 的分支</h3><p>当分支处理内容比较多时，可以用代码块 <code>{}</code> 来做处理，<strong>代码块里最后一个表达式就是结果，也就是返回值，只在表达式体函数中有效</strong>。</p>
<pre><code>// 分支逻辑用代码块的形式
fun evalWithLogging(e: Expr): Int =
    when (e) {
        is Num -&gt; {
            println(&quot;num: ${e.value}&quot;)
            // 最后一行表达式就是结果
            e.value
        }
        is Sum -&gt; {
            val left = evalWithLogging(e.left)
            val right = evalWithLogging(e.right)
            left + right
        }
        else -&gt; throw IllegalArgumentException(&quot;Unkonw expression&quot;)
    }
</code></pre><h2 id="循环和迭代"><a href="#循环和迭代" class="headerlink" title="循环和迭代"></a>循环和迭代</h2><h3 id="“while”-循环"><a href="#“while”-循环" class="headerlink" title="“while” 循环"></a>“while” 循环</h3><p><code>Kotlin</code> 中 <code>while</code> 和 <code>do-while</code> 循环与 <code>Java</code> 完全一致，这里不再过多叙述。</p>
<h3 id="迭代数字：区间和数列"><a href="#迭代数字：区间和数列" class="headerlink" title="迭代数字：区间和数列"></a>迭代数字：区间和数列</h3><p><code>Kotlin</code> 里不再使用 <code>Java</code> 中的常规 <code>for</code> 循环了(初始化变量——循环更新值——值满足某个条件后退出循环)，而是使用区间，区间本质上就是两个值之间的间隔，这两个值通常是数字：一个起始值和一个结束值，使用 <code>..</code> 运算符来表示区间：</p>
<pre><code>val oneToTen = 1..10
</code></pre><p>注意：区间默认是闭合的，即包含最后一个值，如果不想包含最后一个值，可以用 <code>until</code> 函数来实现，比如： <code>1 until 10</code> ，等价于 <code>1..9</code> 。 <code>until</code> 函数非常实用，假如有一个数量为 <code>10</code> 的列表 <code>list</code> 需要遍历所有的索引，那么索引就是从 <code>0 until list.size()</code> 。</p>
<p>接下来，我们用整数迭代来玩 <code>Fizz-Buzz</code> 游戏。游戏玩家轮流递增计数，遇到能被 <code>3</code> 整除的数字就用单词 <code>fizz</code> 代替，遇到能被 <code>5</code> 整除的数字则用单词 <code>buzz</code> 代替，如果一个数字是 <code>3</code> 和 <code>5</code> 的公倍数，你得说 <code>FizzBuzz</code> 。</p>
<pre><code>fun game(value: Int) =
    when {
        value % 15 == 0 -&gt; &quot;FizzBuzz &quot;
        value % 5 == 0 -&gt; &quot;Buzz &quot;
        value % 3 == 0 -&gt; &quot;Fizz &quot;
        else -&gt; &quot;$value &quot;
    }

fun playGame() {
    for (value in 1..50) {
        println(game(value))
    }
}
</code></pre><p>把游戏变得复杂一点，只计算奇数的数值，即 <code>1、3、5..49</code> ，可以用 <code>setp 2</code> 来实现，如下：</p>
<pre><code>fun playGame() {
    for (value in 1..50 step 2) {
        println(game(value))
    }
}
</code></pre><p>再把游戏变得复杂一点，从 <code>50</code> 开始倒着计算到 <code>0</code> ，并且只计算偶数，实现如下：</p>
<pre><code>fun playGameDown() {
    for (value in 50 downTo 0 step 2) {
        println(game(value))
    }
}
</code></pre><h3 id="迭代-map"><a href="#迭代-map" class="headerlink" title="迭代 map"></a>迭代 map</h3><p>我们用一个打印字符二进制表示的程序作为例子：</p>
<pre><code>fun printCharBinary() {
    // 使用 TreeMap 让键来排序
    val binaryReps = TreeMap&lt;Char, String&gt;()
    // 使用字符区间从 A 到 F 之间的字符
    for (c in &apos;A&apos;..&apos;F&apos;) {
        // 把 ASCII 码转换成二进制
        val binary = Integer.toBinaryString(c.toInt())
        // 根据键把值存储到 map 中 ，等价于 binaryReps.put(c,binary)
        binaryReps[c] = binary
    }

    // 迭代 map ，把键和值赋给两个变量
    for ((letter, binary) in binaryReps) {
        println(&quot;$letter == $binary&quot;)
    }
}
</code></pre><p><code>..</code> 语法不仅可以创建数字区间，还可以创建字符区间。这里展示了 <code>for</code> 循环的展开语法，把展开的结果存到了两个独立的变量中。 <code>map</code> 中提供根据键来访问和更新 <code>map</code> 的简明语法。使用 <code>map[key]</code> 读取值，并使用 <code>map[key] = value</code> 设置它们，而不需要调用 <code>get</code> 和 <code>put</code> 。</p>
<p>你还可以使用展开语法来迭代集合的同时跟踪当前项的下标，不再需要创建一个单独的变量来存储下标并手动增加它：</p>
<pre><code>// 打印带索引下标的集合
fun printList() {
    val list = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
    for ((index, element) in list.withIndex()) {
        println(&quot;$index == $element&quot;)
    }
}
</code></pre><h3 id="使用-“in”-检查集合和区间的成员"><a href="#使用-“in”-检查集合和区间的成员" class="headerlink" title="使用 “in” 检查集合和区间的成员"></a>使用 “in” 检查集合和区间的成员</h3><p>使用 <code>in</code> 运算符来检查一个值是否在区间中，或者它的逆运算 <code>!in</code> 来检查这个值是否不在区间中。下面展示了如何用 <code>in</code> 来检查一个字符是否属于一个字符区间：</p>
<pre><code>// 判断字符是否是字母
fun isLetter(c: Char) = c in &apos;a&apos;..&apos;z&apos; || c in &apos;A&apos;..&apos;Z&apos;

// 判断字符是否不是数字
fun isNotDigit(c: Char) = c !in &apos;0&apos;..&apos;9&apos;
</code></pre><p>在 <code>when</code> 中也可以用 <code>in</code> 或 <code>!in</code> 运算符，示例如下：</p>
<pre><code>// 用 when 的方式来处理
fun recognize(c: Char) = when (c) {
    in &apos;a&apos;..&apos;z&apos;, in &apos;A&apos;..&apos;Z&apos; -&gt; &quot;It is a letter!&quot;
    in &apos;0&apos;..&apos;9&apos; -&gt; &quot;It is a digit!&quot;
    else -&gt; &quot;I don&apos;t know !&quot;
}
</code></pre><p>在集合中也可以用，示例如下：</p>
<pre><code>println(&quot;Kotlin&quot; in setOf(&quot;Java&quot;, &quot;Scala&quot;, &quot;Kotlin&quot;))
println(&quot;Kotlin&quot; in &quot;Java&quot;..&quot;Scala&quot;)
</code></pre><h2 id="Kotlin-中的异常"><a href="#Kotlin-中的异常" class="headerlink" title="Kotlin 中的异常"></a>Kotlin 中的异常</h2><p><code>Kotlin</code> 的异常处理和 <code>Java</code> 类似，但不必使用 <code>new</code> 关键字来创建异常实例，并且 <code>throw</code> 结构也是一个有返回值的表达式，比如：</p>
<pre><code>fun throwExpection(value: Int) =
    if (value &gt; 0) value else throw IllegalArgumentException(&quot;value == $value&quot;)
</code></pre><h3 id="try、-catch、-finally"><a href="#try、-catch、-finally" class="headerlink" title="try、 catch、 finally"></a>try、 catch、 finally</h3><p>和 <code>Java</code> 一样，使用带有 <code>catch</code> 和 <code>finally</code> 子句的 <code>try</code> 结构来处理异常，<code>try</code> 也是一个有返回值的表达式，而不是语句，所以也可以在表达式体函数中直接返回，下面这个例子从给定的文件中读取一行，尝试把它解析成一个数字，返回这个数字；或者当这一行不是一个有效数字时返回 <code>null</code> 。</p>
<pre><code>fun readNumber(reader: BufferedReader): Int? =
    try {
        val line = reader.readLine()
        Integer.parseInt(line)
    } catch (e: NumberFormatException) { // 异常类型在右边
        null
    } finally {
        reader.close()
    }
</code></pre><p>和 <code>Java</code> 最大的区别就是 <code>throws</code> 子句没有出现在代码中：如果用 <code>Java</code> 来写这个函数，你会显示地在函数声明的后写上 <code>throws IOException</code> 。你需要这样做的原因是 <code>IOException</code> 是一个受检异常。在 <code>Java</code> 中，这种异常必须显示地处理。必须申明你的函数能抛出的所有受检异常。如果调用另外一个函数，需要处理这个函数的受检异常，或者声明你的函数也能抛出这些异常。和其他许多现在 <code>JVM</code> 语言一样，<code>Kotlin</code> 并不区分受检异常和未受检异常。不用指定函数抛出的异常，而且可以处理也可以不处理异常。</p>
<p><strong>注意： 如果一个 try 代码块执行一切正常，代码块中最后一个表达式就是结果，如果捕获到了异常，相应 catch 代码中最后一个表达式就是结果。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>fun</code> 关键字用来声明函数，<code>val</code> 和 <code>var</code> 关键字分别用来声明只读变量和可变变量。</li>
<li>字符串模板帮助你避免烦琐的字符串拼接，在变量名称前加上 <code>$</code> 前缀或者用 <code>${}</code> 包围一个表达式，来把值注入到字符串中。</li>
<li>值对象类在 <code>kotlin</code> 中以简洁的方式表示。</li>
<li>熟悉的 <code>if</code> 现在是带返回值的表达式。</li>
<li><code>when</code> 表达式类似于 <code>Java</code> 中的 <code>switch</code> ，但功能更强大。</li>
<li>在检查过变量具有某种类型之后不必再显式地转换它的类型。</li>
<li><code>for</code> 循环迭代更加方便了，特别是当你需要迭代 <code>map</code> 的时候，又或是迭代集合需要下标的时候。</li>
<li>用简洁的 <code>..</code> 语法创建区间，还可以使用 <code>in</code> 或 <code>!in</code> 来判断值是否属于某个区间。</li>
<li>不再要求声明函数可以抛出的异常。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kotlin/" rel="tag"><i class="fa fa-tag"></i> kotlin</a>
          
            <a href="/tags/基础/" rel="tag"><i class="fa fa-tag"></i> 基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/27/github/Retrofit2/ARouter 源码详解二/" rel="next" title="ARouter 源码详解二">
                <i class="fa fa-chevron-left"></i> ARouter 源码详解二
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/30/kotlin/KotlinFunction/" rel="prev" title="函数的定义与调用">
                函数的定义与调用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
	  <div id="gitalk-container"></div>   
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/images/avatar.jpg"
               alt="Fanda" />
          <p class="site-author-name" itemprop="name">Fanda</p>
           
              <p class="site-description motion-element" itemprop="description">IT相关技术</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">70</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fandazeng" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/fandazeng" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/fandazeng" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-group"></i>
                  
                  掘金
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/fandazeng" target="_blank" title="JianShu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  JianShu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本要素：函数和变量"><span class="nav-number">1.</span> <span class="nav-text">基本要素：函数和变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">1.1.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语句和表达式的区别"><span class="nav-number">1.2.</span> <span class="nav-text">语句和表达式的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表达式函数体"><span class="nav-number">1.3.</span> <span class="nav-text">表达式函数体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型推导"><span class="nav-number">1.4.</span> <span class="nav-text">类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">1.5.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变变量和不可变变量"><span class="nav-number">1.6.</span> <span class="nav-text">可变变量和不可变变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串模板"><span class="nav-number">1.7.</span> <span class="nav-text">字符串模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类和属性"><span class="nav-number">2.</span> <span class="nav-text">类和属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性"><span class="nav-number">2.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义访问器"><span class="nav-number">2.2.</span> <span class="nav-text">自定义访问器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kotlin-源码布局：目录和包"><span class="nav-number">2.3.</span> <span class="nav-text">Kotlin 源码布局：目录和包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表示和处理选择：枚举和-“when”"><span class="nav-number">3.</span> <span class="nav-text">表示和处理选择：枚举和 “when”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#声明枚举类"><span class="nav-number">3.1.</span> <span class="nav-text">声明枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-“when”-处理枚举类"><span class="nav-number">3.2.</span> <span class="nav-text">使用 “when” 处理枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在-“when”-结构中使用任意对象"><span class="nav-number">3.3.</span> <span class="nav-text">在 “when” 结构中使用任意对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用不带参数的-“when”"><span class="nav-number">3.4.</span> <span class="nav-text">使用不带参数的 “when”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#智能转换"><span class="nav-number">3.5.</span> <span class="nav-text">智能转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码块作为-“when”-的分支"><span class="nav-number">3.6.</span> <span class="nav-text">代码块作为 “when” 的分支</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环和迭代"><span class="nav-number">4.</span> <span class="nav-text">循环和迭代</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#“while”-循环"><span class="nav-number">4.1.</span> <span class="nav-text">“while” 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代数字：区间和数列"><span class="nav-number">4.2.</span> <span class="nav-text">迭代数字：区间和数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代-map"><span class="nav-number">4.3.</span> <span class="nav-text">迭代 map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-“in”-检查集合和区间的成员"><span class="nav-number">4.4.</span> <span class="nav-text">使用 “in” 检查集合和区间的成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kotlin-中的异常"><span class="nav-number">5.</span> <span class="nav-text">Kotlin 中的异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#try、-catch、-finally"><span class="nav-number">5.1.</span> <span class="nav-text">try、 catch、 finally</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
	
	<div id="music163player">
		<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66"></iframe>
	</div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-Fanda"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fanda</span>
</div>

<div>
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>




        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/canvasline.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/baidu_tools.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>


  


  




	





  





  





  






  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '0a24ec23db863f69c94e',
          clientSecret: '454d8ed43ceaa65490b7a854f7cef0b95b7e3be6',
          repo: 'fandazeng.github.io',
          owner: 'fandazeng',
          admin: ['fandazeng'],
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>

  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("eROyoFH3H91PrCEieToSBnny-gzGzoHsz", "D5CAVRJl32bxjAlfHhdpWlAA");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  


</body>
</html>