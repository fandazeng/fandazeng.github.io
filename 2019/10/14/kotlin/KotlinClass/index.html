<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #555; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #555, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #555;    /*上边框颜色*/
        border-left-color: #555;    /*左边框颜色*/
    }
</style>









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="kotlin,类、对象和接口,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1">






<meta name="description" content="定义类的继承结构Kotlin 中的接口Kotlin 的接口可以包含抽象方法的定义以及非抽象方法的实现( 与 Java 8 中的默认方法类似)，但它们不能包含任何状态。跟 Java 一样，用 interface 来声明一个接口： interface Clickable{     fun click() } 让我们看看如何实现这个接口： class Button : Clickable {     o">
<meta name="keywords" content="kotlin,类、对象和接口">
<meta property="og:type" content="article">
<meta property="og:title" content="类、对象和接口">
<meta property="og:url" content="http://fandazeng.github.io/2019/10/14/kotlin/KotlinClass/index.html">
<meta property="og:site_name" content="FandaCode">
<meta property="og:description" content="定义类的继承结构Kotlin 中的接口Kotlin 的接口可以包含抽象方法的定义以及非抽象方法的实现( 与 Java 8 中的默认方法类似)，但它们不能包含任何状态。跟 Java 一样，用 interface 来声明一个接口： interface Clickable{     fun click() } 让我们看看如何实现这个接口： class Button : Clickable {     o">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-03-06T10:19:34.535Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="类、对象和接口">
<meta name="twitter:description" content="定义类的继承结构Kotlin 中的接口Kotlin 的接口可以包含抽象方法的定义以及非抽象方法的实现( 与 Java 8 中的默认方法类似)，但它们不能包含任何状态。跟 Java 一样，用 interface 来声明一个接口： interface Clickable{     fun click() } 让我们看看如何实现这个接口： class Button : Clickable {     o">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://fandazeng.github.io/2019/10/14/kotlin/KotlinClass/">





     <title> 类、对象和接口 | FandaCode </title>
</head>




<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  
  
  <div class="bg_content">
    <div class="filter"></div>
    <canvas id="canvas"></canvas>
  </div>
 <script src="js/src/jquery.min.js"></script>
  
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
	<a href="https://github.com/fandazeng" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a>    
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FandaCode</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">IT相关技术</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user-circle-o"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>
	

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://fandazeng.github.io/2019/10/14/kotlin/KotlinClass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fanda">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FandaCode">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">类、对象和接口</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-14T10:45:08+08:00">
                2019-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">kotlin</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kotlin/类、对象和接口/" itemprop="url" rel="index">
                    <span itemprop="name">类、对象和接口</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/10/14/kotlin/KotlinClass/" class="leancloud_visitors" data-flag-title="类、对象和接口">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="定义类的继承结构"><a href="#定义类的继承结构" class="headerlink" title="定义类的继承结构"></a>定义类的继承结构</h2><h3 id="Kotlin-中的接口"><a href="#Kotlin-中的接口" class="headerlink" title="Kotlin 中的接口"></a>Kotlin 中的接口</h3><p><code>Kotlin</code> 的接口可以包含抽象方法的定义以及非抽象方法的实现( 与 <code>Java 8</code> 中的默认方法类似)，但它们不能包含任何状态。跟 <code>Java</code> 一样，用 <code>interface</code> 来声明一个接口：</p>
<pre><code>interface Clickable{
    fun click()
}
</code></pre><p>让我们看看如何实现这个接口：</p>
<pre><code>class Button : Clickable {
    override fun click() = println(&quot;I was clicked&quot;)
}
</code></pre><p><code>Kotlin</code> 在类名后面使用<strong>冒号</strong>来代替 <code>Java</code> 中的 <code>extends</code> 和 <code>implements</code> 关键字，跟 <code>Java</code> 一样，也是单继承和多实现。在 <code>Kotlin</code> 中，用 <code>override</code> 修饰符来标注被重写的父类或接口的方法和属性，且是强制性的，而不用 <code>Java</code> 可选的 <code>@Override</code> 注解，这样可以避免方法的意外重写。</p>
<p>接口的方法可以有一个默认的实现，在 <code>Java 8</code> 需要你在这样的方法上标注 <code>default</code> 关键字，而 <code>Kotlin</code> 不需要特殊的标识，只需要提供一个方法体：</p>
<pre><code>// 定义一个接口
interface Clickable {
    fun click()

    // 接口带默认实现
    fun showOff() = println(&quot;I am a clickable!&quot;)
}

// 接口实现类
class Button : Clickable {
    override fun click() = println(&quot;I was clicked&quot;)
}
</code></pre><p>实现上述接口时，有默认实现的方法可以不重写，也可以重写实现自己的逻辑，没有默认实现的方法必须重写实现。</p>
<p><strong>注意：在 Java 中，并不支持 Kotlin 的这种接口默认实现，必须重写所有的方法，因为 Kotlin 是以 Java6 为目标设计的，Java 8 及以上版本才支持接口默认实现。</strong></p>
<p>那么 <code>Kotlin</code> 的接口默认方法是怎样实现的呢？其实，<code>Kotlin</code> 的接口默认实现，会把每个带默认方法的接口编译成一个普通接口和一个将方法体作为静态函数的类的结合体，我们来看一下生成的 <code>Java</code> 代码：</p>
<pre><code>public final class Button implements Clickable {
   public void click() {
      String var1 = &quot;I was clicked&quot;;
      System.out.println(var1);
   }

   public void showOff() {
      // 默认调用对应的默认方法体对应的静态函数
      Clickable.DefaultImpls.showOff(this);
   }
}

public interface Clickable {
   // 普通接口方法
   void click();
   void showOff();

    // 静态内部类
   public static final class DefaultImpls {
      // 默认方法体实现对应的静态函数
      public static void showOff(Clickable $this) {
         String var1 = &quot;I am a clickable!&quot;;
         System.out.println(var1);
      }
   }
}
</code></pre><p>代码可知，接口实际上并没有默认实现，会把默认实现转换成对应的静态函数实现。</p>
<p>假设，有两个不同的接口，但有同名的默认实现方法，如果某个类实现了这两个接口，那么调用的是哪个接口的默认实现呢？实际上，会编译错误，需要显式重写自己的实现，因为编译器无法知道要调用哪个，示例代码如下：</p>
<pre><code>// 接口实现类
class Button : Clickable, Focusable {
    override fun click() = println(&quot;I was clicked&quot;)

    override fun showOff() {
        super&lt;Clickable&gt;.showOff()
        super&lt;Focusable&gt;.showOff()
    }

}

interface Focusable {
    // 接口带默认实现
    fun showOff() = println(&quot;I am a Focusable!&quot;)
}
</code></pre><p>因为有两个同名的 <code>showOff</code> 默认实现，所以需要重写 <code>showOff</code> 函数，这里通过 <code>super</code> 来调用接口或基类的实现，只是语法跟 <code>Java</code> 有点不同，<code>super&lt;Clickable&gt;.showOff()</code> 类似于  <code>Clickable.super.showOff()</code> 。</p>
<h3 id="open、final和abstract-修饰符：默认-final"><a href="#open、final和abstract-修饰符：默认-final" class="headerlink" title="open、final和abstract 修饰符：默认 final"></a>open、final和abstract 修饰符：默认 final</h3><p>在 <code>Java</code> 中，允许你创建任意类的子类并重写任意方法，除非显式使用 <code>final</code> 关键字进行标注，这通常很方便，但子类如果出现预期之外的方法重写，就会出问题。所以，<code>Kotlin</code> 采用了默认是 <code>final</code> 的思想，如果你想允许创建一个类的子类，需要使用 <code>open</code> 修饰符来标注，还要给每个可以被重写的属性和函数添加 <code>open</code> 标注符。</p>
<pre><code>open class RichButton : Clickable{  // 这个类是 open 的，可以被其他类继承

    fun disable(){}     //这个函数是 final 的，不能被子类重写

    open fun animate(){}    //这个函数是 open 的，可以被子类重写

    override fun click() {} //这个函数重写了一个 open 函数并且本身也是 open 的

}
</code></pre><p><strong>注意：如果重写了基类或接口的成员，默认还是 open 的，想要阻止子类继承重写，可以显式地指定重写成员为 final 的。</strong></p>
<pre><code>final override fun click() {} //显式标记final，阻止子类重写
</code></pre><p>在 <code>Kotlin</code> 中 ，也可以将类声明为抽象(abstract)的 ，这种类不能被实例化，跟接口一样，默认是 <code>open</code> 的。跟接口的区别是：接口里面的方法默认都是 <code>open</code> 的，无论方法有没有默认实现。而抽象类里面只有抽象方法是 <code>open</code> ，非抽象方法默认不是 <code>open</code> 的，但是可以标注为 <code>open</code> 。</p>
<pre><code>// 抽象类，默认为 open
abstract class Animated{

    abstract fun animate()      // 抽象方法，默认为 open

    fun animateTwice() {}       // 非抽象方法，默认为 final

    open fun stopAnimating(){}  // 非抽象方法，显式指定是 open

} 
</code></pre><h3 id="可见性修饰符：-默认为-public"><a href="#可见性修饰符：-默认为-public" class="headerlink" title="可见性修饰符： 默认为 public"></a>可见性修饰符： 默认为 public</h3><ol>
<li><p>在 <code>Kotlin</code> 中，如果省略了修饰符，默认就是 <code>public</code> ，而 <code>Java</code> 默认是包私有。</p>
</li>
<li><p><code>Kotlin</code> 提供了一个新的修饰符 <code>internal</code> ，表示只在模块内部可见，提供了对模块实现细节的真正封装。使用 <code>Java</code> 时，这种封装很容易被破坏，因为外部代码可以将类定义到与你代码相同的包中，从而得到访问你包私有声明的权限。 </p>
</li>
<li><p><code>Kotlin</code> 允许在顶层声明中使用 <code>private</code> 可见性，包括类、函数和属性，这些声明只会在声明它们的文件中可见。</p>
</li>
<li><p><code>Kotlin</code> 不允许在包中访问 <code>protected</code> 的成员，<code>protected</code> 成员只在类和子类中可见，这是跟 <code>Java</code> 的重要区别。</p>
</li>
<li><p>类的扩展函数不能访问它的 <code>private</code> 和 <code>protected</code> 成员属性和函数。</p>
</li>
<li><p><code>Kotlin</code> 中的 <code>private</code> 类在 <code>Java</code> 中会被编译成包私有声明，因为 <code>Java</code> 中不能把类声明为 <code>private</code> 的，而 <code>internal</code> 修饰符会在 <code>Java</code> 字节码中变成 <code>public</code> 。</p>
</li>
<li><p><code>Kotlin</code> 中的外部类不能看到其内部类或嵌套类中的 <code>private</code> 成员。</p>
</li>
</ol>
<p>第一个例子：</p>
<pre><code>internal open class TalkativeButton : Focusable {

    private fun yell() = println(&quot;Hey!&quot;)

    protected fun whisper() = println(&quot;Let is talk !&quot;)
}

fun TalkativeButton.giveSpeech() {   // 这里报错，需要加上 internal
    yell()     // 这里报错，无法调用 private 方法

    whisper()   // 这里报错，无法调用 protected 方法
}
</code></pre><p>第二个例子：</p>
<pre><code>// Java 代码
public class ObjectPraticeJava {

    private static InnerClass innerClass = new InnerClass();

    public static void main(String[] args) {
        // 可以访问嵌套类的 private 成员
        System.out.println(innerClass.age);
    }

    static class InnerClass {
        private int age = 18;
    }
}

// kotlin 代码
class ObjectPratice {

    private val innerClass: MyInnerClass = MyInnerClass()

    fun main() {
        // 不能访问嵌套类的 private 成员，会报错
        println(innerClass.age)
    }

    class MyInnerClass {
        private val age = 18
    }
}
</code></pre><h3 id="内部类和嵌套类：默认是嵌套类"><a href="#内部类和嵌套类：默认是嵌套类" class="headerlink" title="内部类和嵌套类：默认是嵌套类"></a>内部类和嵌套类：默认是嵌套类</h3><p>在 <code>Java</code> 中 ，内部类会持有外部类引用，这层引用关系通常很容易被忽略而造成内存泄露和意料之外的问题，而嵌套类不会。因此，在 <code>Kotlin</code> 中 ，默认是嵌套类，如果想要声明成内部类，需要显式地使用 <code>inner</code> 修饰符。</p>
<pre><code>// Java 代码
class Outer {

    class Inner {
        //内部类，持有外部类的应用
    }

    static class Nested {
        //嵌套类，不持有外部类
    }
}

// kotlin 代码
class OuterClass{

    // 这是嵌套类，不持有外部类引用
    class NestedClass{

    }

    // 这是内部类，持有外部类引用
    inner class innerClass{ //声明  inner

    }

}
</code></pre><p>在 <code>Java</code> 中，内部类通过 <code>OuterClass.this</code> 来获取外部类的对象，而 <code>kotlin</code> 则是通过 <code>this@OuterClass</code> 获得外部类对象。</p>
<pre><code>// 这是内部类，持有外部类引用
inner class innerClass{ //声明  inner
    fun getOuter() = this@OuterClass
}
</code></pre><h3 id="密封类：-定义受限的类继承结构"><a href="#密封类：-定义受限的类继承结构" class="headerlink" title="密封类： 定义受限的类继承结构"></a>密封类： 定义受限的类继承结构</h3><p><code>Kotlin</code> 提供了一个 <code>sealed</code> 修饰符来对可能创建的子类做出严格的限制，<code>sealed</code> 修饰的类默认就是 <code>open</code> 的，所以无需显式添加 <code>open</code> 修饰符。在 <code>Kotlin 1.0</code> 中 , <code>sealed</code> 修饰的类的子类必需嵌套到父类里面，而在 <code>1.1</code> 版本以后，允许在<strong>同一文件</strong>的任何位置定义 <code>sealed</code> 类的子类。</p>
<p>当文件中只存在一个 sealed 类时，我们分别看一下对应的 Kotlin 和 Java 代码：</p>
<pre><code>// Kotlin 代码
sealed class Expr

// Java 代码，变成了抽象类
public abstract class Expr {
    // 私有构造
   private Expr() {
   }
}
</code></pre><p>从上面的代码得知 <code>sealed</code> 类会变成抽象类，且私有构造函数，所以在其他文件中继承 <code>sealed</code> 类是不可能的，因为不能初始化父类，<strong>但是在同一文件可以实现子类</strong>。</p>
<pre><code>// 简单的值对象，实现 Expr 接口
class Num(val value: Int) : Expr()

// Sum 运算，需要左右两个简单值对象，运用多态，声明成基类
class Sum(val left: Expr, val right: Expr) : Expr()
</code></pre><p>在 <code>sealed</code> 类所在文件中添加了子类后的 Java 代码如下：</p>
<pre><code>public abstract class Expr {
   private Expr() {
   }

   // 多了这个公有构造函数
   // $FF: synthetic method
   public Expr(DefaultConstructorMarker $constructor_marker) {
      this();
   }
}
</code></pre><p>子类就是同通过上述这个公有构造函数来初始化父类的，但是不同文件中创建子类时，会提示私有构造，无法创建。如果你在 <code>when</code> 表达式中处理了所有 <code>sealed</code> 类的子类，你就不再需要提供默认分支了：</p>
<pre><code>// 如果表达式是 Num 类型，直接返回值，如果是 Sum 类型，先计算左右表达式的值再求和
fun eval(e: Expr): Int =
    when (e) {
        // 用 is 判断实例，不需要再强转
        is Num -&gt; e.value
        is Sum -&gt; eval(e.left) + eval(e.right)
//        else -&gt; throw Exception(&quot;error&quot;)  // 不需要了，已经覆盖所有的情况
    }
</code></pre><p>如果添加了新的 <code>sealed</code> 类的子类，<code>when</code> 表达式会报错，避免忘记添加新分支(会走默认分支选项)导致的潜在问题。</p>
<h2 id="声明一个带非默认构造方法或属性的类"><a href="#声明一个带非默认构造方法或属性的类" class="headerlink" title="声明一个带非默认构造方法或属性的类"></a>声明一个带非默认构造方法或属性的类</h2><p><code>Java</code> 中可以声明一个或多个构造方法，Kotlin 也一样，只是做了一点修改：区分了主构造方法（通常是主要而简洁的初始化类的方法，并且在<strong>类体外部</strong>声明）和从构造方法（在<strong>类体内部</strong>声明）。同样也允许在初始化语句块中添加额外的初始化逻辑。</p>
<h3 id="初始化类：主构造方法和初始化语句块"><a href="#初始化类：主构造方法和初始化语句块" class="headerlink" title="初始化类：主构造方法和初始化语句块"></a>初始化类：主构造方法和初始化语句块</h3><p>我们之前声明一个简单类是这样写的：</p>
<pre><code>class User(val nickName: String)
</code></pre><p>这里的 <code>(val nickName: String)</code> 语句块叫做<strong>主构造方法</strong>，它主要有两个目的：表明构造方法的参数，以及定义使用这些参数初始化的属性，转化为 <code>Java</code> 代码会容易理解：</p>
<pre><code>public final class User {
   @NotNull
   private final String nickName;

   @NotNull
   public final String getNickName() {
      return this.nickName;
   }

   // 构造方法，定义了参数
   public User(@NotNull String nickName) {
      // 使用这个参数初始化属性
      this.nickName = nickName;
   }
}
</code></pre><p>我们来看一下不用简洁方式实现的代码：</p>
<pre><code>class User constructor(nickName: String, age: Int) {
    val nickName: String
    val age: Int

    // 初始化语句块
    init {
        this.nickName = nickName
    }

    init {
        this.age = 18
    }
}
</code></pre><p>这里出现了两个关键字： <code>constructor</code> 和 <code>init</code> 。 <code>constructor</code> 关键字用来声明一个主构造或从构造方法，<code>init</code> 关键字引入一个初始化语句块，在类被创建时执行，配合主构造方法来完成初始化 ,<code>init</code> 语句块可以有多个。转换成 <code>Java</code> 代码是这样的：</p>
<pre><code>public final class User {
   @NotNull
   private final String nickName;
   private final int age;

   @NotNull
   public final String getNickName() {
      return this.nickName;
   }

   public final int getAge() {
      return this.age;
   }

   public User(@NotNull String nickName, int age) {
      this.nickName = nickName;
      this.age = 18;
   }
}
</code></pre><p>其实 <code>init</code> 初始化语句可以与属性相结合，并且如果主构造方法没有注解或可见性修饰符，可以去掉 <code>constructor</code> 关键字，那么会变成这样：</p>
<pre><code>// 省略 constructor，属性与初始化语句结合
class User(_nickName: String, _age: Int) {
    val nickName: String = _nickName
    val age: Int = _age
}
</code></pre><p>由于命名问题，我们把主构造的参数前面加上 <code>_</code> 来表示区分，通过类型推导可以省略掉类型，变成这样：</p>
<pre><code>// 省略 constructor，属性与初始化语句结合
class User(_nickName: String, _age: Int) {
    val nickName = _nickName
    val age = _age
}
</code></pre><p>如果属性用构造方法参数来初始化，可以通过把 <code>val</code> 关键字加在参数前来进行简化，参数的名称就变成属性名称了，而且该属性使用这些参数初始化。</p>
<pre><code>class User(val nickName: String,val age: Int) 
</code></pre><p><strong>注意：没有说一定是加上 val ，加上 var 也是一样的，只是 val 和 var 的区别罢了。</strong></p>
<pre><code>// kotlin
class Son(var grade: Int)

// Java
public final class Son {
    // 没有 final
   private int grade;

   public final int getGrade() {
      return this.grade;
   }

    // 多了 set 方法
   public final void setGrade(int var1) {
      this.grade = var1;
   }

   public Son(int grade) {
      this.grade = grade;
   }
}
</code></pre><p>跟其他函数一样，构造方法也可以设置默认值：</p>
<pre><code>// 构造方法有默认值
class User(val nickName: String = &quot;fanda&quot;,val age: Int = 18)
</code></pre><p>注意，方法参数的类型是不能省略的，比如，不能这样写：</p>
<pre><code>class User(val nickName = &quot;fanda&quot;,val age = 18)
</code></pre><p>为了能让 <code>Java</code> 也能享受默认参数的好处，可以用 <code>@JvmOverloads</code> 注解修饰构造器，这时候，<code>constructor</code> 不能省略了：</p>
<pre><code>// 构造方法有默认值
class UserSuper @JvmOverloads constructor(val nickName: String = &quot;fanda&quot;,val age: Int = 18)
</code></pre><p>这里的构造方法的使用，跟普通带有默认值的函数的使用完全一样，可以通过命名参数来指定参数。如果你的类具有一个父类，主构造方法同样需要初始化父类，可以通过在基类列表的父类引用中提供父类构造方法参数的方式来做到：</p>
<pre><code>// 构造方法有默认值
open class UserSuper(val nickName: String = &quot;fanda&quot;, val age: Int = 18)

// 有父类，需要把参数传递给父类来初始化
class User(val myName: String, nickName: String, age: Int) : UserSuper(nickName, age)
</code></pre><p>注意： <code>val myName: String</code> 表示这个是 <code>User</code> 的属性，并利用该参数赋值，而 <code>nickName</code> 和 <code>age</code> 并不是 <code>User</code> 的属性，仅仅只是参数而已，只要是用来传递给父类 <code>UserSuper</code> 的属性进行赋值，我们来看一下生成的 Java 代码：</p>
<pre><code>public final class User extends UserSuper {
   // 只有这个是 User 的属性
   @NotNull
   private final String myName;

   @NotNull
   public final String getMyName() {
      return this.myName;
   }

   public User(@NotNull String myName, @NotNull String nickName, int age) {
      // nickname 和 age 传递给父类
      super(nickName, age);
      this.myName = myName;
   }
}
</code></pre><p><strong>再重申一下： var 和 val 加在主构造方法的参数前面，是用来简化属性和初始化操作的，参数与对应的属性才能关联上，如果构造方法前面没有关键字 var 和 val ，那仅仅是参数的传递，不会生成属性。</strong></p>
<p>如果没有给一个类声明任何构造方法，将会生成一个无参默认构造方法，继承该类的子类需要显式调用父类的无参构造：</p>
<pre><code>interface Run
open class Car
class Bus : Car(), Run
</code></pre><p>注意到<code>Car()</code> 后面的 <code>()</code> 了吧，这也是与接口的区别，接口没有构造，因此没有 <code>()</code> 。</p>
<p>如果你不想类在外部被实例化，比如提供工厂方法来实例化对象，那么需要私有化构造方法，在 <code>constructor</code> 前面加上 <code>private</code> 即可：</p>
<pre><code>class Bus private constructor(): Car(), Run
</code></pre><h3 id="构造方法：用不同的方式来初始化父类"><a href="#构造方法：用不同的方式来初始化父类" class="headerlink" title="构造方法：用不同的方式来初始化父类"></a>构造方法：用不同的方式来初始化父类</h3><p>参数默认值和参数命名的语法涵盖了重载函数的场景了，但是如果你一定要声明多个构造方法，也是可以的(实际上没有必要)。</p>
<pre><code>open class View {
    constructor(ctx: Context)
    constructor(ctx: Context, attrs: String)
}

class MyView : View {

    val mContext: Context
    val mAttrs: String

    //    constructor(ctx: Context):super(ctx)
    constructor(ctx: Context) : this(ctx, &quot;default&quot;)    // 从构造方法

    // super 用于父类的初始化
    constructor(ctx: Context, attrs: String) : super(ctx, attrs) {// 从构造方法
        mContext = ctx
        mAttrs = attrs
    }
}
</code></pre><p>这个类没有声明主构造方法，声明两个从构造方法，从构造方法必须使用 <code>constructor</code> 来声明，子类使用 <code>super</code> 关键字调用对应的父类构造方法，也可以使用 <code>this</code> 关键字，从一个构造方法调用另一个构造方法。</p>
<p><strong>注意：如果定义了主构造方法，所有的从构造方法都必须直接或间接调用主构造方法。</strong></p>
<pre><code>open class OtherView(){
//    constructor(ctx: Context) : this()// 从构造方法
    constructor(ctx: Context) : this(ctx, &quot;default&quot;)// 从构造方法
    constructor(ctx: Context, attrs: String) :this()     // 从构造方法
}

open class OtherView(count: Int) {
    //    constructor(ctx: Context) : this()// 从构造方法
    constructor(ctx: Context) : this(ctx, &quot;default&quot;)// 从构造方法

    constructor(ctx: Context, attrs: String) : this(count = 10)      // 从构造方法
}
</code></pre><p>我们再来分析一下同时有主构造和从构造的情况：</p>
<pre><code>class OtherClient(val name: String) {
    var postalCode: Int = 0

    constructor(_postalCode: Int) : this(&quot;&quot;) {
        this.postalCode = _postalCode
    }
}
</code></pre><p>上述类 <code>OtherClient</code> 会有两个构造方法，第一个是只传入 <code>name</code> ，第二个是只传入 <code>postalCode</code> 。这里的 <code>postalCode</code> 不能声明为 <code>val</code> 的，因为如果调用的是只传入 <code>name</code> 的构造，假设 <code>postalCode</code> 是 <code>val</code> 的，那么 <code>postalCode</code> 必须先进行初始化。但是如果属性被初始化了，第二个只传入 <code>postalCode</code> 的构造又能够重新赋值，这是 <code>val</code> 不允许，因此互相矛盾了。最终 <code>postalCode</code> 只能声明为 <code>var</code> 的并进行初始化，确保调用第一个只传入 <code>name</code> 的构造时，<code>postalCode</code> 有值，而且能够被只传入 <code>postalCode</code> 的构造重新赋值。</p>
<p><strong>重申一下：从构造函数必须直接或间接调用主构造方法，因为如果调用了只传入 postalCode 的构造方法，val 修饰和 name 属性必须要有值，上述代码传入了 “” ，就算主构造方法没有参数，也要调用主构造的无参构造。</strong></p>
<h3 id="实现在接口中声明的属性"><a href="#实现在接口中声明的属性" class="headerlink" title="实现在接口中声明的属性"></a>实现在接口中声明的属性</h3><p>在 <code>Kotlin</code> 中 ，接口可以包含抽象属性声明，但接口本身不包含任何状态，所以并没有说明这个值应该存储到一个支持字段还是通过 <code>getter</code> 来获取。</p>
<pre><code>interface IUser{
    // 声明一个抽象属性
    val nickName: String
}
</code></pre><p>上面其实定义的不是字段，而是 <code>val</code> 代表了 <code>getter</code> 方法，对应的 <code>Java</code> 代码：</p>
<pre><code>public interface IUser {
   @NotNull
   String getNickName();
}
</code></pre><p>第一种实现方式：</p>
<pre><code>// 直接用最简语法，实现接口抽象属性，需要加上 override
class privateUser(override val nickName: String) : IUser

// Java 代码
public final class privateUser implements IUser {
   @NotNull
   private final String nickName;

   @NotNull
   public String getNickName() {
      return this.nickName;
   }

   public privateUser(@NotNull String nickName) {
      this.nickName = nickName;
   }
}
</code></pre><p>可以看到，接口的抽象属性在实现类中变成字段了，在构造方法中初始化，并有 <code>getter</code> 方法。</p>
<p>第二种实现方式：</p>
<pre><code>class CallUser(val email: String) : IUser {
    override val nickName: String
        get() = email.substringBefore(&quot;@&quot;)  //只有 getter 方法，不是字段
}
</code></pre><p>这种实现方式中，<code>nickName</code> 不是字段，只提供了一个 <code>getter</code> 方法而已，每次获取 <code>nickName</code> 时，都会调用 <code>getter</code> 方法。</p>
<p>第三种实现方式：</p>
<pre><code>class BookUser(val accountId: Int) : IUser {
    override val nickName = getBookName(accountId)

    fun getBookName(accountId: Int) = &quot;$accountId@name&quot; //有字段支持

}
</code></pre><p>这种实现方式和第二种有些类似，实际上完全不一样，这里的 <code>nickName</code> 是有字段支持的，并且和属性 <code>accountId</code> 相关联，即在 <code>accountId</code> 属性进行初始化时，<code>nickName</code> 也会进行初始化进行存储，每次获取的是初始化存储好的值，想象一下，如果 <code>getBookName</code> 方法开销非常大，这种方式非常有优势。</p>
<p>我们来看一下对应的 <code>Java</code> 代码，会容易理解：</p>
<pre><code>public final class BookUser implements IUser {
   @NotNull
   private final String nickName;
   private final int accountId;

   @NotNull
   public String getNickName() {
      return this.nickName;
   }

   @NotNull
   public final String getBookName(int accountId) {
      return accountId + &quot;@name&quot;;
   }

   public final int getAccountId() {
      return this.accountId;
   }

   public BookUser(int accountId) {
      this.accountId = accountId;
      this.nickName = this.getBookName(this.accountId);
   }
}
</code></pre><p><strong>注意：除了抽象属性声明外，接口还可以包含具有 <code>getter</code> 和 <code>setter</code> 的属性，只要它们没有一个支持字段(支持字段需要在接口中存储状态，这是不允许的)。</strong></p>
<pre><code>interface ITeacher {
    //这是抽象属性，需要重写
    val email: String   
    // 这个属性可以被继承，但是没有字段支持，每次会调用 getter 方法
    val nickName: String   
        get() = email.substringBefore(&quot;@&quot;)
}
</code></pre><h3 id="通过-getter-或-setter-访问支持字段"><a href="#通过-getter-或-setter-访问支持字段" class="headerlink" title="通过 getter 或 setter 访问支持字段"></a>通过 getter 或 setter 访问支持字段</h3><p>现在我们结合有字段支持的属性和具有自定义访问器的例子：</p>
<pre><code>class Doctor(val name: String){
    var address:String =&quot;default&quot;
    set(value) {
        println(&quot;&quot;&quot;
            Address was changed for $name: &quot;$field&quot; -&gt; &quot;$value&quot;.
        &quot;&quot;&quot;.trimIndent())
        field = value
    }
}

输出
Address was changed for fanda: &quot;default&quot; -&gt; &quot;xilichaguang&quot;.
</code></pre><p>上述的类在对属性 <code>address</code> 进行修改时都会输出日志，因为自定义了 <code>setter</code> 访问器来处理了一些额外的逻辑。在 <code>setter</code> 的函数体中，使用了特殊的标识符 <code>field</code> 来访问支持字段的值。在 <code>getter</code> 中，只能读取值，而在 <code>setter</code> 中既能读取值也能修改值。这里没有自定义 <code>getter</code> 方法，直接返回字段的值即可，无需额外逻辑。</p>
<h3 id="修改访问器的可见性"><a href="#修改访问器的可见性" class="headerlink" title="修改访问器的可见性"></a>修改访问器的可见性</h3><p>访问器的可见性默认与属性的可见性相同，但是可以通过在访问器前添加可见性修饰符来修改它：</p>
<pre><code>class LengthCounter{
    var counter: Int = 0
    private set     // 变成私有的，不能在类外部修改这个属性

    fun addWord(word: String) {
        counter+= word.length
    }
}
</code></pre><p>上述代码把属性 <code>counter</code> 的 <code>set</code> 方法变成 <code>private</code> 的，因此 <code>setter</code> 方法是不会再自动生成了，因为不能在类外部修改这个属性了，没有必要生成。但是 <code>getter</code> 方法还是有的，这里提供了一个 <code>addWord</code> 方法来对属性 <code>counter</code> 来进行修改，而不再使用默认的 <code>setter</code> ，我们看一下对应生成的 <code>Java</code> 代码：</p>
<pre><code>public final class LengthCounter {
   private int counter;

   public final int getCounter() {
      return this.counter;
   }

   public final void addWord(@NotNull String word) {
      this.counter += word.length();
   }
}
</code></pre><p><strong>注意：如果直接在属性前设置 private，那么对应的 set 和 get 访问器都不会生成，等同于分别在对应的 set 或 get 访问器前放置 private 。</strong></p>
<h2 id="编译器生成的方法：数据类和类委托"><a href="#编译器生成的方法：数据类和类委托" class="headerlink" title="编译器生成的方法：数据类和类委托"></a>编译器生成的方法：数据类和类委托</h2><h3 id="通用对象方法"><a href="#通用对象方法" class="headerlink" title="通用对象方法"></a>通用对象方法</h3><p>我们先来看看 <code>Java</code> 中常见的 <code>toString</code> 、 <code>equals</code> 和 <code>hasCode</code> 方法在 <code>kotlin</code> 中是如何重写的：</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><pre><code>class Client(val name: String, val postalCode: Int) {
    override fun toString(): String {
        return &quot;Client(name=$name,postalCode=$postalCode)&quot;
    }
}

// 输出 Client(name=fanda,postalCode=123456)
println(Client(&quot;fanda&quot;, 123456))
</code></pre><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>在 <code>Java</code> 中， <code>==</code> 运算符如果应用在基本数据类型上比较的是值，而在引用类型上比较的是引用，所以在 <code>Java</code> 中通常总是调用 <code>equals</code> 方法。而在 <code>Kotlin</code> 中 ，<code>==</code> 运算符就是 <code>Java</code> 中的 <code>equals</code> ，如果想要比较引用，需要用到 <code>===</code> 运算符。</p>
<pre><code>class Client(val name: String, val postalCode: Int) {
    override fun equals(other: Any?): Boolean {
        if (other == null || other !is Client) {
            return false
        }
        // 因为上面判断了类型，所以这里编译器会对 other 进行智能转换为 Client
        return name == other.name &amp;&amp; postalCode == other.postalCode
    }
}
</code></pre><p><code>Any</code> 是 <code>java.lang.Object</code> 的模拟： <code>Kotlin</code> 中所有类的父类。可空类型 <code>Any?</code> 意味着 <code>other</code> 有可能为 <code>null</code> 。在 <code>Kotlin</code> 中所有可能为 <code>null</code> 的情况都需要显式标明，即在类型后面加上<code>？</code> 。</p>
<h4 id="hasCode"><a href="#hasCode" class="headerlink" title="hasCode"></a>hasCode</h4><p><code>hashCode</code> 方法通常与 <code>equals</code> 一起被重写，因为通用的 <code>hashCode</code> 契约：如果两个对象相等，他们必须有着相同的 <code>hash</code> 值。</p>
<pre><code>class Client(val name: String, val postalCode: Int) {
    override fun hashCode(): Int {
        return name.hashCode() * 31 + postalCode
    }
}
</code></pre><p>我们来测试一下上述三个方法是否被重写时，下面代码的输出是怎样的：</p>
<pre><code>val client = Client(&quot;fanda&quot;, 123456)
val client2 = Client(&quot;fanda&quot;, 123456)
val hashSet = hashSetOf(client)

println(client.toString())
println(client == client2)
println(hashSet.contains(client2))

//没被重写时，会输出
zeng.fanda.com.kotlinpratice.object.Client@372f7a8d
false
false

//被重写时，会输出
Client(name=fanda,postalCode=123456)
true
true
</code></pre><p>上述的三个方法在数据容器 <code>bean</code> 通过都是要被重写的，并且基本上都是用工具自动生成的，而现在 <code>kotlin</code> 编译器能够帮助自动生成这些方法，而不需要显式地手动生成。</p>
<h3 id="数据类：自动生成通用方法的实现"><a href="#数据类：自动生成通用方法的实现" class="headerlink" title="数据类：自动生成通用方法的实现"></a>数据类：自动生成通用方法的实现</h3><p>只需要在类前面加上 <code>data</code> 修饰符，上述三个方法将会自动生成，非常方便。</p>
<pre><code>data class NewClient(val name: String, val postalCode: Int)
</code></pre><p>我们来测试一下：</p>
<pre><code>fun testClient() {
    val client = NewClient(&quot;fanda&quot;, 123456)
    val client2 = NewClient(&quot;fanda&quot;, 123456)
    val hashSet = hashSetOf(client)

    println(client.toString())
    println(client == client2)
    println(hashSet.contains(client2))
}

// 输出
NewClient(name=fanda, postalCode=123456)
true
true
</code></pre><p>这种数据类，有两点需要注意的地方：</p>
<ol>
<li><p><code>data</code> 修饰的类，必须要有主构造方法，并且至少要有一个属性。</p>
</li>
<li><p>不在主构造方法里面的属性，不会加入到上述三个方法的处理逻辑中去。</p>
</li>
<li><p>属性最好使用 <code>val</code> 来修饰，让数据类的实例不可变，避免多线程等情况属性值被改变导致的各种问题。</p>
</li>
</ol>
<p>我们来看一下例子：</p>
<pre><code>data class OtherClient(val name: String) {
    var postalCode: Int = 0

    constructor(_postalCode: Int) : this(&quot;&quot;) {
        this.postalCode = _postalCode
    }
}
</code></pre><p>上述 <code>OtherClient</code> 类的 <code>postalCode</code> 属性将不会加入到上述三个方法的处理逻辑中去。我们来测试一下：</p>
<pre><code>val client = OtherClient(&quot;fanda&quot;)
client.postalCode = 123456
val client2 = OtherClient(&quot;fanda&quot;)
client2.postalCode = 123456

println(client.toString())

//输出，并没有 postalCode 属性
OtherClient(name=fanda)
</code></pre><p>具体生成的对应的方法逻辑是没有 <code>postalCode</code> 属性的，可以研究一下生成的 <code>Java</code> 代码。</p>
<p>为了让使用不可变对象的数据类变得更容易，<code>Kotlin</code> 编译器为它们多生成了一个方法，一个允许 <code>copy</code> 类的实例的方法，并在 <code>copy</code> 的同时修改某些属性的值。下面是手动实现 <code>copy</code> 方法后看起来的样子：</p>
<pre><code>class Client(val name: String, val postalCode: Int) {
    fun copy(name: String = this.name, postalCode: Int = this.postalCode) = Client(name, postalCode)
}
</code></pre><p>从上述方法可知，<code>copy</code> 方法的默认参数值就是属性的值，也可以单独修改一些属性的值。</p>
<p><strong>注意： 使用 data 类自动生成的 copy 方法，copy 的属性只包括主构造的属性，跟上述自动生成的三个方法的一样。</strong></p>
<pre><code>val client = OtherClient(&quot;fanda&quot;)
client.postalCode = 123456

println(client.copy(&quot;liuhang&quot;).name)
println(client.copy(&quot;liuhang&quot;).postalCode)    // 这里将输出 0 ，而不是 123456

//输出
liuhang
0
</code></pre><h3 id="类委托：使用-“by”-关键字"><a href="#类委托：使用-“by”-关键字" class="headerlink" title="类委托：使用 “by” 关键字"></a>类委托：使用 “by” 关键字</h3><p><code>Java</code> 中通常采用装饰器模式来向其他类添加一些行为。这种模式的本质就是创建一个新类，实现与原始类一样的接口并将原来的类的实例作为一个字段保存，与原始类拥有同样行为的方法不用修改，只需要直接转发到原始类的实例。这种方式的一个缺点是需要相当多的模板代码。例如我们来实现一个 <code>Collection</code> 的接口的装饰器，即使你不需要修改任何的行为：</p>
<pre><code>// 装饰类
class DelegationCollection&lt;T&gt; : Collection&lt;T&gt; { // 实现与原始类同样的接口
    // 原始类保存为字段
    private val innerList = arrayListOf&lt;T&gt;()

    // 分别转发原始类对应的方法
    override val size = innerList.size
    override fun contains(element: T) = innerList.contains(element)
    override fun containsAll(elements: Collection&lt;T&gt;) = innerList.containsAll(elements)
    override fun isEmpty() = innerList.isEmpty()
    override fun iterator() = innerList.iterator()
}
</code></pre><p>观察上述代码，典型的装饰类处理，里面有相当多的模板代码，而 <code>Kotlin</code> 对这种委托做了语言级别的支持。无论什么时候实现一个接口，你都可以使用 <code>by</code> 关键字将接口的实现委托到另一个对象，我们利用这个特征来重构上述代码：</p>
<pre><code>class DelegationCollection&lt;T&gt;(private val innerList: Collection&lt;T&gt; = ArrayList()) : Collection&lt;T&gt; by innerList
</code></pre><p>类中所有的方法都不需要写了，编译器会生成它们，如果需要改变某些方法的逻辑，重写那些方法即可：</p>
<pre><code>class DelegationCollection&lt;T&gt;(private val innerList: Collection&lt;T&gt; = ArrayList()) : Collection&lt;T&gt; by innerList{
    var count = 0

    override fun isEmpty(): Boolean {
        count++
        return innerList.isEmpty()
    }
}
</code></pre><p>上述代码重写了 <code>isEmpty</code> 函数，其他函数实现还是委托给对应的内部实例 <code>innerList</code> 。</p>
<h2 id="object-关键字：将声明一个类与创建一个实例结合起来"><a href="#object-关键字：将声明一个类与创建一个实例结合起来" class="headerlink" title="object 关键字：将声明一个类与创建一个实例结合起来"></a>object 关键字：将声明一个类与创建一个实例结合起来</h2><p><code>Kotlin</code> 中 <code>object</code> 关键字在多种情况下出现，但是他们都遵循同样的核心理念：这个关键字定义一个类并同时创建一个实例对象，有以下使用场景：</p>
<ul>
<li>对象声明是定义<strong>单例</strong>的一种方式。</li>
<li>伴生对象可以持有工厂方法和其他与这个类相关，但在调用时并不依赖实例的方法，它们的成员可以通过类名来访问。</li>
<li>对象表达式用来替代 <code>Java</code> 的匿名内部类。</li>
</ul>
<h3 id="对象声明：创建单例"><a href="#对象声明：创建单例" class="headerlink" title="对象声明：创建单例"></a>对象声明：创建单例</h3><p>单例模式是 <code>Java</code> 中常见的设计模式，在 <code>Kotlin</code> 中通过使用对象声明功能为这一切提供了最高级的语言支持，对象声明将类声明与该类的单一实例声明结合到了一起。</p>
<pre><code>class Person

// 对象声明，不需要 class ，将类声明与该类的单一实例声明结合到了一起
object Payroll{
    val allEmplayees = arrayListOf&lt;Person&gt;()

    fun calculateSalary() {
        for (person in allEmplayees) {
            //...
        }
    }
}
</code></pre><p>对象声明用 <code>object</code> 来替代 <code>class</code> 来声明类，与普通类一样，一个对象声明也可以包含属性，方法，初始化语句块等声明。</p>
<p><strong>注意： 对象声明不允许有构造函数，无论是主构造还是从构造，对象声明在定义的时候就立即创建了，不需要在代码的其他地方调用构造方法。</strong></p>
<p>与变量一样，对象声明允许你使用对象名加 <code>.</code> 字符的方式来调用方法和访问属性：</p>
<pre><code>Payroll.allEmplayees.add(Person())
Payroll.calculateSalary()
</code></pre><p>对象声明跟普通类一起，也可以继承类和实现接口，让我们实现一个忽略大小写比较文件路径的比较器：</p>
<pre><code>object FileComparator : Comparator&lt;File&gt; {
    override fun compare(o1: File, o2: File): Int {
        return o1.path.compareTo(o2.path, ignoreCase = true)
    }
}

println(FileComparator.compare(File(&quot;/User&quot;), File(&quot;/user&quot;)))
</code></pre><p>也可以在任何使用普通对象的地方使用单例对象，例如：</p>
<pre><code>val files = listOf(File(&quot;/Z&quot;), File(&quot;/a&quot;))
println(files.sortedWith(FileComparator))
</code></pre><p><strong>注意：单例对象名就是对象本身，可以看作普通对象一样使用，只不过这个对象是一个单例的而已，因为是对象本身，所以用 . 来访问方法和属性是很正常的。</strong></p>
<p>同样的，也可以在类内部声明对象，就像声明普通类一样：</p>
<pre><code>data class Man(val name: String) {
    object NameComparator : Comparator&lt;Man&gt; {
        override fun compare(o1: Man, o2: Man): Int {
            return o1.name.compareTo(o2.name)
        }
    }
}

val manList = listOf(Man(&quot;fanda&quot;), Man(&quot;hehe&quot;))
println(manList.sortedWith(Man.NameComparator))
</code></pre><p>那么，在 <code>Java</code> 中如何使用 <code>Kotlin</code> 声明的单例对象呢？我们先来看一下 <code>FileComparator</code> 转换成 <code>Java</code> 的代码是怎样的：</p>
<pre><code>public final class FileComparator implements Comparator {
   // 静态字段持有单一实例，该字段名字始终是 INSTANCE
   public static final FileComparator INSTANCE;

   public int compare(@NotNull File o1, @NotNull File o2) {
        ...
   }

   // 私有化构造方法，不让外部创建实例
   private FileComparator() {
   }

   // 静态代码块，初始化实例，只有在类加载时调用一次
   static {
      FileComparator var0 = new FileComparator();
      INSTANCE = var0;
   }
}
</code></pre><p>答案很明显了，要从 <code>Java</code> 代码使用 <code>kotlin</code> 单例对象，可以通过访问静态的 <code>INSTANCE</code> 字段，比如：</p>
<pre><code>System.out.println(FileComparator.INSTANCE.compare(new File(&quot;/User&quot;), new File(&quot;/user&quot;)));
</code></pre><h3 id="伴生对象：工厂方法和静态成员的地盘"><a href="#伴生对象：工厂方法和静态成员的地盘" class="headerlink" title="伴生对象：工厂方法和静态成员的地盘"></a>伴生对象：工厂方法和静态成员的地盘</h3><p><code>Kotlin</code> 中的类不能拥有静态成员： <code>Java</code> 的 <code>static</code> 关键字并不是 <code>Kotlin</code> 语言的一部分。作为代替， <code>Kotlin</code> 依赖包级别函数（在大多数情况下能够替代 Java 的静态方法）和对象声明（在其他情况下替代 Java 的静态方法，同时还包括静态字段）。在大多数情况下，还是推荐使用顶层函数，但是顶层函数不能访问类的 <code>private</code> 成员。特别是 <code>Java</code> 中常见的工厂方法和类中需要使用的 <code>static</code> 成员该如何定义呢？</p>
<p>这时候就要使用伴生对象了。伴生对象是在类中定义的对象前添加一个特殊的关键字来标记： <code>companion</code> 。这样做，就获得了直接通过容器类名称来访问这个这个对象的方法和属性的能力，不再需要显示得指明对象的名称，最终的语法看起来非常像 <code>Java</code> 中的静态方法调用：</p>
<pre><code>// 伴生对象
class Dog{
    companion object ObjectDog{
         val age = 5
        fun run() {
            println(&quot;I am running&quot;)
        }
    }
}
</code></pre><p>调用的时候是这样的：</p>
<pre><code>println(Dog.age)
println(Dog.ObjectDog.run())
println(Dog.run())    // 省略 ObjectDog
</code></pre><p><code>ObjectDog</code> 是可以省略掉的，直接调用对应的属性和方法即可，是不是非常类似于 <code>Java</code> 类内声明的静态变量和方法。我们来看一下转化为 <code>Java</code> 时的代码：</p>
<pre><code>public final class Dog {
    // 伴生对象里面声明的属性会变成静态属性
   private static final int age = 5;
    // 生成一个 public static 的伴生对象类
   public static final Dog.ObjectDog ObjectDog = new Dog.ObjectDog((DefaultConstructorMarker)null);

   public static final class ObjectDog {
      public final int getAge() {
         return Dog.age;
      }

      public final void run() {
         String var1 = &quot;I am running&quot;;
         boolean var2 = false;
         System.out.println(var1);
      }

      private ObjectDog() {
      }

      // $FF: synthetic method
      public ObjectDog(DefaultConstructorMarker $constructor_marker) {
         this();
      }
   }
}
</code></pre><p>因此，在 <code>Java</code> 中如果要使用伴生对象的话，需要这样使用：</p>
<pre><code>// Java 使用时，ObjectDog 不能省略
System.out.println( Dog.ObjectDog.getAge());
Dog.ObjectDog.run();
</code></pre><p>在 <code>Kotlin</code> 中，因为伴生对象的类名在调用时是可以省略的，可以在声明上也可以省略掉，如下：</p>
<pre><code>// 伴生对象
class Dog{
    companion object {    // 省略掉伴生对象名称
         val age = 5
        fun run() {
            println(&quot;I am running&quot;)
        }
    }
}
</code></pre><p>如果是这种情况的话， <code>Java</code> 该如何调用呢？其实，如果省略掉伴生对象名称，编译器也会生成一个默认的类名，叫做　<code>Companion</code>　，如下：</p>
<pre><code>public final class Dog {
   private static final int age = 5;
    // 现在用的是默认生成的名字， Companion
   public static final Dog.Companion Companion = new Dog.Companion((DefaultConstructorMarker)null);

    //　类名为　Companion
   public static final class Companion {
      public final int getAge() {
         return Dog.age;
      }

      public final void run() {
         String var1 = &quot;I am running&quot;;
         boolean var2 = false;
         System.out.println(var1);
      }

      private Companion() {
      }

      // $FF: synthetic method
      public Companion(DefaultConstructorMarker $constructor_marker) {
         this();
      }
   }
}
</code></pre><p>那么在调用的时候，只需要把对应的名称换成　<code>Companion</code>　即可。</p>
<p>那么在类内声明对象和声明伴生对象，到底有什么区别呢？我们为声明一个类似的类内对象：</p>
<pre><code>class Cat{
     object ObjectCat{
        val age = 5
        fun run() {
            println(&quot;I am running&quot;)
        }
    }
}
</code></pre><p>首先有第一个区别，类内声明对象一定要有类名，不能省略掉，因为属性和方法的调用是通过类名进行的，调用的时候就像在　<code>Java</code> 中调用伴生对象一样：</p>
<pre><code>// ObjectCat 不能省略
println(Cat.ObjectCat.age)
println(Cat.ObjectCat.run())
</code></pre><p>这是调用上的区别，还有就是生成的 <code>Java</code> 代码其实完全不一样，我们看一下：</p>
<pre><code>public final class Cat {

   public static final class ObjectCat {
      // 对象里面声明的属性会变成静态属性，但在单例对象里层
      private static final int age = 5;
      public static final Cat.ObjectCat INSTANCE;

      public final int getAge() {
         return age;
      }

      public final void run() {
         String var1 = &quot;I am running&quot;;
         boolean var2 = false;
         System.out.println(var1);
      }

      private ObjectCat() {
      }

      static {
         Cat.ObjectCat var0 = new Cat.ObjectCat();
         INSTANCE = var0;
         age = 5;
      }
   }
}
</code></pre><p>首先静态属性是属于单例对象的(伴生对象是属于外部类的)，外部类也不持有内部声明的对象，这也说明了为什么不能省略对象名称。</p>
<p>总结一下：</p>
<ol>
<li><p><code>object</code> 声明的对象是单例对象，可以直接通过对象名称对调用方法和访问属性，仅此而已，就算该对象是声明在某个类内，但是这个对象是独立的，其实跟外部类没有多大关系，是一个嵌套类罢了。</p>
</li>
<li><p><code>companion object</code> 声明的是伴生对象，从叫法上就能知道，肯定跟外部类是有关联的，伴生对象的属性会变成外部类的静态属性，外部类会持有伴生对象，可以通过持有的伴生对象调用对于的方法，语法上是可以省略掉的，即可以通过外部类来直接调用伴生对象的属性和方法(跟 Java 的静态变量和方法调用变得一致了)，所以如果想实现 <code>Java</code> 类内的静态变量和静态方法，完全可以通过伴生对象来实现。</p>
</li>
<li><p>伴生对象是可以访问到外部类的私有构造方法的。</p>
</li>
</ol>
<p>在 <code>Java</code> 中通过私有化构造方法，然后提供工厂方法来提供该类的实例，而在 <code>Kotlin</code> 中的实现方式就是通过伴生对象，因为伴生对象是可以访问到外部类的私有构造方法的：</p>
<pre><code>data class User private constructor(val nickName: String) {   // 有一个私有的构造方法的数据类

    companion object {
        // 工厂方法生成 User 对象
        fun newCallUser(email: String) = User(email.substringBefore(&quot;@&quot;))
        fun newBookUser(accountId: Int) = User(getBookName(accountId))

        private fun getBookName(accountId: Int) = &quot;$accountId@name&quot; //有字段支持
    }
}

//调用
println(User.newCallUser(&quot;2543533434@qq.com&quot;))
println(User.newBookUser(435730))
</code></pre><p>如果想让 <code>Java</code> 调用伴生对象时，也有一致的体验，可以利用注解来实现，用  <code>@JvmField</code> 注解表示声明一个 <code>static</code> 字段 ，用 <code>@JvmStatic</code> 表示声明一个 <code>static</code> 方法，例如：</p>
<pre><code>// 伴生对象
class Dog {

    companion object {
        @JvmField
        val age = 5
        @JvmStatic
        fun run() {
            println(&quot;I am running&quot;)
        }
    }
}
</code></pre><p>此时，在 <code>Java</code> 中调用就有一致的体验了：</p>
<pre><code>System.out.println( Dog.age);
Dog.run();
</code></pre><p><strong>注意： 伴生对象其实也跟普通类一样，也可以继承其他类和实现接口，如果继承或实现接口了，就等同于外部类也一样继承或实现接口了，当有一个函数使用抽象方法来加载实体，可以传入外部类。</strong></p>
<pre><code>interface IEat {
    fun eat()
}

open class Base

// 伴生对象
class Dog {
    companion object : IEat, Base() {
        override fun eat() {
            println(&quot;I am eating&quot;)
        }

        @JvmField
        val age = 5

        @JvmStatic
        fun run() {
            println(&quot;I am running&quot;)
        }
    }
}
</code></pre><p>最后说明一点，伴生对象也可以声明扩展函数，如果类 <code>C</code> 有一个伴生对象，并且在<code>C.Companion</code> 上定义了一个扩展函数 <code>func</code> ，可以通过 <code>C.func()</code> 来调用它：</p>
<pre><code>// 伴生对象的扩展
class C {
    companion object 
}

fun C.Companion.func() {
    println(&quot;我是扩展函数&quot;)
}

// 调用
C.func()
</code></pre><h3 id="对象表达式：改变写法的匿名内部类"><a href="#对象表达式：改变写法的匿名内部类" class="headerlink" title="对象表达式：改变写法的匿名内部类"></a>对象表达式：改变写法的匿名内部类</h3><p><code>object</code> 关键字不仅仅能用来声明单例对象，还能用来声明匿名对象，匿名对象替代了 <code>Java</code> 中匿名内部类的用法，比如：</p>
<pre><code>// Java 代码
interface Listener{
    void onClick();
}

static class TestView{
    private Listener listener;

    public void setListener(Listener listener) {
        this.listener = listener;
    }
}

new TestView().setListener(new Listener() {
    @Override
    public void onClick() {

    }
});
</code></pre><p>在 <code>Kotlin</code> 中调用是这样的：</p>
<pre><code>ObjectPraticeJava.TestView().setListener(object : ObjectPraticeJava.Listener {
    override fun onClick() {

    }
})
</code></pre><p><strong>注意：与对象声明不同，匿名对象不是单例的，每次对象表达式被执行都会创建一个新的对象实例。并且访问创建匿名内部类的函数中的变量是没有限制在final变量，还可以在对象表达式中修改变量的值，而 Java 不行。</strong></p>
<p><code>Java</code> 示例代码如下：</p>
<pre><code>// 必须声明为 final
final int clickCount = 0 ;
new TestView().setListener(new Listener() {

    @Override
    public void onClick() {
        // 这里只能读取，不能做修改，因为是 final 类型
        System.out.println(clickCount);
    }
});
</code></pre><p><code>Kotlin</code> 示例代码如下：</p>
<pre><code>// 不用定义为 val
var clickCount = 0
ObjectPraticeJava.TestView().setListener(object : ObjectPraticeJava.Listener {
    override fun onClick() {
        // 可以任意修改
        clickCount++
        println(clickCount)
    }
})
</code></pre><p>为什么会这样呢？我们来查看一下转化为 <code>Java</code> 的代码：</p>
<pre><code>public static final void testNoneNameInnerClass() {
   final IntRef clickCount = new IntRef();
   clickCount.element = 0;
   (new TestView()).setListener((Listener)(new Listener() {
      public void onClick() {
         int var1 = clickCount.element++;
      }
   }));
}
</code></pre><p>原来是生成了一个包装类来包装了我们定义的 <code>clickCount</code>，<code>final</code> 属性也声明在了该包装类中。</p>
<p><strong>注意：与 Java 匿名内部类只能扩展一个类或实现一个接口不同，Kotlin 的匿名对象可以实现多个接口或不实现接口。可以把实现多个接口的匿名对象保存在变量中，然后在需要不同接口实现的匿名对象的方法中都传入同一个匿名对象，这非常方便</strong></p>
<p>示例如下：</p>
<pre><code>// 将实现多个接口的匿名对象保存到属性 listener 中
val listener = object : ObjectPraticeJava.Listener, ObjectPraticeJava.LongClickListener {
    override fun onClick() {
    }

    override fun onLongClick() {
    }
}
// 在需要不同接口实现的匿名对象的方法中都传入同一个匿名对象
ObjectPraticeJava.TestView().setListener(listener)
ObjectPraticeJava.TestView().setLongClickListener(listener)
</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>Kotlin</code> 的接口与 <code>Java</code> 相似，但是可以包含默认实现(<code>Java 8</code> 开始支持)和属性。</li>
<li>所有的声明默认都是 <code>final</code> 和 <code>public</code> 的。</li>
<li>要想使声明不是 <code>final</code> ，将其标记为 <code>open</code> 。</li>
<li><code>internal</code> 声明在同一模块中可见。</li>
<li>嵌套类默认不是内部类。使用 <code>inner</code> 关键字来存储外部类的引用。</li>
<li>类委托帮助避免在代码中出现许多相似的委托方法。</li>
<li>对象声明是 <code>Kotlin</code> 中定义单例类的方法。</li>
<li>伴生对象（与包级别函数和属性一起）替代了 <code>Java</code> 静态方法和字段定义。</li>
<li>伴生对象与其他对象一一样，可以实现接口，也可以拥有扩展函数和属性。</li>
<li>对象表达式是 <code>Kotlin</code> 中针对 <code>Java</code> 匿名内部类的替代品，并增加了诸如实现多个接口的能力和修改在创建对象的作用域中定义的变量的能力等功能。</li>
<li>使用 <code>field</code> 标识符在访问器方法体中引用属性的支持字段。</li>
<li>数据类提供了编译器生成的 <code>equals</code> 、 <code>hashCode</code> 、 <code>toString</code> 、<code>copy</code> 和其他方法。</li>
<li><code>sealed</code> 类的子类只能嵌套在自身的声明中(<code>kotlin 1.1</code> 允许将子类放置在同一文件的任意地方)。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kotlin/" rel="tag"><i class="fa fa-tag"></i> kotlin</a>
          
            <a href="/tags/类、对象和接口/" rel="tag"><i class="fa fa-tag"></i> 类、对象和接口</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/30/kotlin/KotlinFunction/" rel="next" title="函数的定义与调用">
                <i class="fa fa-chevron-left"></i> 函数的定义与调用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/18/kotlin/KotlinLambda/" rel="prev" title="Lambda 编程">
                Lambda 编程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
	  <div id="gitalk-container"></div>   
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/images/avatar.jpg" alt="Fanda">
          <p class="site-author-name" itemprop="name">Fanda</p>
           
              <p class="site-description motion-element" itemprop="description">IT相关技术</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">80</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fandazeng" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/fandazeng" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/fandazeng" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-group"></i>
                  
                  掘金
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/fandazeng" target="_blank" title="JianShu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  JianShu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义类的继承结构"><span class="nav-number">1.</span> <span class="nav-text">定义类的继承结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kotlin-中的接口"><span class="nav-number">1.1.</span> <span class="nav-text">Kotlin 中的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#open、final和abstract-修饰符：默认-final"><span class="nav-number">1.2.</span> <span class="nav-text">open、final和abstract 修饰符：默认 final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可见性修饰符：-默认为-public"><span class="nav-number">1.3.</span> <span class="nav-text">可见性修饰符： 默认为 public</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类和嵌套类：默认是嵌套类"><span class="nav-number">1.4.</span> <span class="nav-text">内部类和嵌套类：默认是嵌套类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#密封类：-定义受限的类继承结构"><span class="nav-number">1.5.</span> <span class="nav-text">密封类： 定义受限的类继承结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明一个带非默认构造方法或属性的类"><span class="nav-number">2.</span> <span class="nav-text">声明一个带非默认构造方法或属性的类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化类：主构造方法和初始化语句块"><span class="nav-number">2.1.</span> <span class="nav-text">初始化类：主构造方法和初始化语句块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法：用不同的方式来初始化父类"><span class="nav-number">2.2.</span> <span class="nav-text">构造方法：用不同的方式来初始化父类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现在接口中声明的属性"><span class="nav-number">2.3.</span> <span class="nav-text">实现在接口中声明的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过-getter-或-setter-访问支持字段"><span class="nav-number">2.4.</span> <span class="nav-text">通过 getter 或 setter 访问支持字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改访问器的可见性"><span class="nav-number">2.5.</span> <span class="nav-text">修改访问器的可见性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译器生成的方法：数据类和类委托"><span class="nav-number">3.</span> <span class="nav-text">编译器生成的方法：数据类和类委托</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通用对象方法"><span class="nav-number">3.1.</span> <span class="nav-text">通用对象方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#toString-NaN"><span class="nav-number">3.1.1.</span> <span class="nav-text">toString</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals"><span class="nav-number">3.1.2.</span> <span class="nav-text">equals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hasCode"><span class="nav-number">3.1.3.</span> <span class="nav-text">hasCode</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类：自动生成通用方法的实现"><span class="nav-number">3.2.</span> <span class="nav-text">数据类：自动生成通用方法的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类委托：使用-“by”-关键字"><span class="nav-number">3.3.</span> <span class="nav-text">类委托：使用 “by” 关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#object-关键字：将声明一个类与创建一个实例结合起来"><span class="nav-number">4.</span> <span class="nav-text">object 关键字：将声明一个类与创建一个实例结合起来</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象声明：创建单例"><span class="nav-number">4.1.</span> <span class="nav-text">对象声明：创建单例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伴生对象：工厂方法和静态成员的地盘"><span class="nav-number">4.2.</span> <span class="nav-text">伴生对象：工厂方法和静态成员的地盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象表达式：改变写法的匿名内部类"><span class="nav-number">4.3.</span> <span class="nav-text">对象表达式：改变写法的匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
	
	<div id="music163player">
		<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66"></iframe>
	</div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-Fanda"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fanda</span>
</div>

<div>
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style="display:none">
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style="display:none">
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>




        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/canvasline.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/baidu_tools.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>


  


  




	





  





  





  






  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '0a24ec23db863f69c94e',
          clientSecret: '454d8ed43ceaa65490b7a854f7cef0b95b7e3be6',
          repo: 'fandazeng.github.io',
          owner: 'fandazeng',
          admin: ['fandazeng'],
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>

  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("eROyoFH3H91PrCEieToSBnny-gzGzoHsz", "D5CAVRJl32bxjAlfHhdpWlAA");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  


</body>
</html>