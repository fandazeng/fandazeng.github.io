<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #555; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #555, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #555;    /*上边框颜色*/
        border-left-color: #555;    /*左边框颜色*/
    }
</style>









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="kotlin,Lambda,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1">






<meta name="description" content="Lambda 表达式和成员引用Lambda 表达式，简称 Lambda ，本质上就是可以传递给其他函数的一小段代码。 Lambda 简介： 作为函数参数的代码块我们来看一个例子，假设你要定义一个按钮的点击行为，添加一个负责处理点击的监听器，监听器实现了相应的接口 OnClickListener 和它的一个方法 onClick： /* Java */ button.setOnClickListene">
<meta name="keywords" content="kotlin,Lambda">
<meta property="og:type" content="article">
<meta property="og:title" content="Lambda 编程">
<meta property="og:url" content="http://fandazeng.github.io/2019/10/18/kotlin/KotlinLambda/index.html">
<meta property="og:site_name" content="FandaCode">
<meta property="og:description" content="Lambda 表达式和成员引用Lambda 表达式，简称 Lambda ，本质上就是可以传递给其他函数的一小段代码。 Lambda 简介： 作为函数参数的代码块我们来看一个例子，假设你要定义一个按钮的点击行为，添加一个负责处理点击的监听器，监听器实现了相应的接口 OnClickListener 和它的一个方法 onClick： /* Java */ button.setOnClickListene">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-03-13T06:53:24.819Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lambda 编程">
<meta name="twitter:description" content="Lambda 表达式和成员引用Lambda 表达式，简称 Lambda ，本质上就是可以传递给其他函数的一小段代码。 Lambda 简介： 作为函数参数的代码块我们来看一个例子，假设你要定义一个按钮的点击行为，添加一个负责处理点击的监听器，监听器实现了相应的接口 OnClickListener 和它的一个方法 onClick： /* Java */ button.setOnClickListene">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://fandazeng.github.io/2019/10/18/kotlin/KotlinLambda/">





     <title> Lambda 编程 | FandaCode </title>
</head>




<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  
  
  <div class="bg_content">
    <div class="filter"></div>
    <canvas id="canvas"></canvas>
  </div>
 <script src="js/src/jquery.min.js"></script>
  
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
	<a href="https://github.com/fandazeng" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a>    
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FandaCode</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">IT相关技术</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user-circle-o"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>
	

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://fandazeng.github.io/2019/10/18/kotlin/KotlinLambda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fanda">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FandaCode">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Lambda 编程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-18T16:06:05+08:00">
                2019-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">kotlin</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kotlin/Lambda/" itemprop="url" rel="index">
                    <span itemprop="name">Lambda</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/10/18/kotlin/KotlinLambda/" class="leancloud_visitors" data-flag-title="Lambda 编程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Lambda-表达式和成员引用"><a href="#Lambda-表达式和成员引用" class="headerlink" title="Lambda 表达式和成员引用"></a>Lambda 表达式和成员引用</h2><p><code>Lambda</code> 表达式，简称 <code>Lambda</code> ，本质上就是可以传递给其他函数的一小段代码。</p>
<h3 id="Lambda-简介：-作为函数参数的代码块"><a href="#Lambda-简介：-作为函数参数的代码块" class="headerlink" title="Lambda 简介： 作为函数参数的代码块"></a>Lambda 简介： 作为函数参数的代码块</h3><p>我们来看一个例子，假设你要定义一个按钮的点击行为，添加一个负责处理点击的监听器，监听器实现了相应的接口 <code>OnClickListener</code> 和它的一个方法 <code>onClick</code>：</p>
<pre><code>/* Java */
button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            //do something
        }
});
</code></pre><p>这样声明匿名内部类的写法实在是太啰嗦了。在 <code>Kotlin</code> 中我们可以像 <code>Java 8</code> 一样使用 <code>lambda</code> 来消除这些冗余代码。</p>
<pre><code>/* Kotlin */
button.setOnClickListener{ /* do someting */ }
</code></pre><h3 id="Lambda-和集合"><a href="#Lambda-和集合" class="headerlink" title="Lambda 和集合"></a>Lambda 和集合</h3><p>我们来看一个例子，你会用到一个 <code>Person</code> 类，它包含了这个人的名字和年龄信息。</p>
<pre><code>data class Person(val name: String, val age: Int)
</code></pre><p>假设你现在有一个 <code>Person</code> 类列表，需要找到列表中年龄最大的那个人，如果完全不了解 <code>lambda</code> ，你可能会这样做：</p>
<pre><code>fun findTheOldest(list: List&lt;Person&gt;) {
    var maxAge = 0
    var theOldestPerson: Person? = null     // ？ 表示可以为null

    for (p in list) {
        if (p.age &gt; maxAge) {
            maxAge = p.age
            theOldestPerson = p
        }
    }
    println(theOldestPerson)
}

val personList = listOf(Person(&quot;fanda&quot;, 18), Person(&quot;liuhang&quot;, 13))
findTheOldest(personList)
</code></pre><p>这样做可以得到结果，但是代码繁多且很容易出错。而在 <code>Kotlin</code> 中可以使用库函数，如下所示：</p>
<pre><code>val personList = listOf(Person(&quot;fanda&quot;, 18), Person(&quot;liuhang&quot;, 13))
personList.maxBy { it.age }
</code></pre><p><code>maxBy</code> 函数可以在任何集合上调用，且只需要一个实参：一个函数，指定比较哪个值来找到最大的元素。 <code>{it.age}</code> 就是实现了这个逻辑的 <code>lambda</code> 。它接收一个集合中的元素作为实参（使用 <code>it</code> 引用它）并且返回用来比较的值。这个例子中，集合元素是 <code>Person</code> 对象，用来比较的是存储在其 <code>age</code> 属性中的年龄。</p>
<p>如果 <code>lambda</code> 刚好是函数或属性的委托，可以用成员引用替换：</p>
<pre><code>// 注意，这里用的是 () ，括号里面是成员引用，成员引用等价于 lambda
personList.maxBy(Person::age)
</code></pre><p>其实，上述用 <code>lambda</code> 的方式可以是这样的：</p>
<pre><code>// 把去掉的括号显示出来
personList.maxBy ({ it.age })
</code></pre><p>虽然 <code>lambda</code> 看上去很简洁，但是你可能不是很明白到底如何写 <code>lambda</code> ，以及里面的规则，我们来学习下 <code>lambda</code> 表达式的语法吧。</p>
<h3 id="Lambda-表达式的语法"><a href="#Lambda-表达式的语法" class="headerlink" title="Lambda 表达式的语法"></a>Lambda 表达式的语法</h3><p>一个 <code>lambda</code> 把一小段行为进行编码，你能把它当作值到处传递，它可以被独立地声明并存储到一个变量中，但是更常见的还是直接声明它并传递给函数。</p>
<pre><code>                  // 参数      //分隔符  // 函数体
{  x: Int, y: Int    -&gt;       x + y }
</code></pre><p><code>Kotlin</code> 的 <code>lambda</code> 表达式始终用花括号包围，实参并没有用括号括起来， <code>-&gt;</code> 把实参列表和函数体隔开，当 <code>lambda</code> 被独立地声明并存储到一个变量中时，可以把这个变量当作普通函数对待(即通过相应实参调用它)。</p>
<pre><code>val lambda = {  x: Int, y: Int -&gt; x + y }    // 存在 lambda 变量中
// 像调用方法一样调用 lambda 表达式
println(lambda(13, 15))
</code></pre><p>上述找到年龄最大的人的例子中，使用的是最简的 <code>lambda</code> 表达式，如果不用任何简明语法来重写那个例子，会是下面这样：</p>
<pre><code>personList.maxBy({ p: Person -&gt; p.age })
</code></pre><p>这段代码一目了然，括号就是函数调用的语法，花括号就是 <code>lambda</code> 表达式，该表达式作为参数传入 <code>maxBy</code> 函数，该表达式接收一个 <code>Person</code> 的参数并返回它的年龄。</p>
<p>但是语法太过啰嗦，可以进行改进，首先是花括号： <code>Kotlin</code> 有这样一种语法约定，如果 <code>lambda</code> 表达式是函数调用的最后一个实参，它可以放到括号的外边，上述 <code>maxBy</code> 函数只有一个参数，明显也就是最后一个实参了，那么可以这样写：</p>
<pre><code>personList.maxBy() { p: Person -&gt; p.age }
</code></pre><p>当 <code>lambda</code> 是函数唯一的实参时，还可以去掉调用代码中的空括号：</p>
<pre><code>// 去掉函数调用的括号
personList.maxBy { p: Person -&gt; p.age }
</code></pre><p>类型可以通过上下文推断出来并可以省略：</p>
<pre><code>personList.maxBy { p -&gt; p.age }        //通过类型推导，省略类型
</code></pre><p>也存在编译器不能推断出 <code>lambda</code> 参数类型的情况，但这里我们暂不讨论。可以遵循这样的一条简单的规则：<strong>先不声明类型，等编译器报错后再来指定它们</strong>。</p>
<p>如果当前上下文期望的是只有一个参数的 <code>lambda</code> 且这个参数的类型可以推断出来，就会生成默认参数名称 <code>it</code> ，这样就不用显式进行参数命名了，即 <code>p</code> 这个命名可以省略了，由于没有了参数，那么 <code>-&gt;</code> 也可以省略掉：</p>
<pre><code>personList.maxBy { it.age }    // it 是自动生成的默认参数名称
</code></pre><p>我们总结一下，以下所有的表达式都是等价的：</p>
<pre><code>personList.maxBy({ p: Person -&gt; p.age })
personList.maxBy() { p: Person -&gt; p.age }
personList.maxBy { p: Person -&gt; p.age }
personList.maxBy { p -&gt; p.age }
personList.maxBy {  it.age }
</code></pre><p><strong>注意：只有当实参名称没有显式指定时，这个默认的名称才会生成，如果指定了，用指定的命名即可。如果上下文中参数的类型或意义不是很明朗或在嵌套 lambda 的情况下，最好显式声明每个 lambda 的参数。当然，如果你用变量存储 lambda ，那么肯定没有可以推断参数类型的上下文，必须显式指定参数类型。</strong></p>
<p>至此，你看到的例子都是单个表达式或语句构成的 <code>lambda</code> ，但是 <code>lambda</code> 并没有被限制在这样小的规模，它可以包含更多的语句。下面这种情况，最后一个表达式就是 (lambda) 的结果：</p>
<pre><code>val sum = {x: Int,y: Int -&gt;
    println(&quot;Computing the sum of $x and $y&quot;)
    x + y
}

println(sum(43,1))
// 输出
Computing the sum of 43 and 1
44
</code></pre><h3 id="在作用域中访问变量"><a href="#在作用域中访问变量" class="headerlink" title="在作用域中访问变量"></a>在作用域中访问变量</h3><p>当在函数内声明一个匿名内部类的时候，能够在这个匿名内部类引用这个函数的参数和局部变量。也可以用 <code>lambda</code> 作同样的事情。如果<strong>在函数内部使用 lambda ，也可以访问这个函数的参数，还有在 lambda 之前定义的局部变量</strong>。</p>
<p>我们用标准库函数 <code>forEach</code> 来展示这种行为。这个函数能够遍历集合中的每一个元素，并在该元素上调用给定的 <code>lambda</code> 。 <code>forEach</code> 函数只是比普通 <code>for</code> 循环更简洁一些，并没有其他性能上的优势。</p>
<pre><code>fun printMessageWithPrefix(messages: Collection&lt;String&gt;, prefix: String) {
    // 接收 lambda 作为实参指定对每个元素的操作
    messages.forEach {
        // 在 lambda 中访问 &quot;prefix&quot; 参数
        println(&quot;$prefix $it&quot;)
    }
}

val errors = listOf(&quot;403 Forbidden&quot;, &quot;404 Not Found&quot;)
printMessageWithPrefix(errors, &quot;Error:&quot;)

// 输出
Error: 403 Forbidden
Error: 404 Not Found
</code></pre><p>和 <code>Java</code> 不一样，<code>Kotlin</code> 允许在 <code>lambda</code> 内部访问非 <code>final</code> 变量甚至修改它们，我们称这些变量被 <code>lambda</code> 捕获，示例如下：</p>
<pre><code>fun printProblemCounts(response: Collection&lt;String&gt;) {
    var clientErrors = 0
    var serverErrors = 0

    response.forEach {
        if (it.startsWith(&quot;4&quot;)) {
            clientErrors++
        } else if (it.startsWith(&quot;5&quot;)) {
            serverErrors++
        }
    }
    println(&quot;$clientErrors client errors, $serverErrors server errors&quot;)
}

val errors = listOf(&quot;403 Forbidden&quot;, &quot;404 Not Found&quot;)
printProblemCounts(errors)
</code></pre><p>它的原理跟我们之前讲的匿名内部类访问非 <code>final</code> 变量甚至修改它们的原理是一样的，当你捕获 <code>final</code> 变量时，它的值和使用这个值的 <code>lambda</code> 代码一起存储。而对非 <code>final</code> 变量来说，它的值被封装在一个特殊的包装器类中，这样你就可以改变这个值，而对这个包装器的引用会和 <code>lambda</code> 代码一起存储。</p>
<h3 id="成员引用"><a href="#成员引用" class="headerlink" title="成员引用"></a>成员引用</h3><p>我们已经看到 <code>lambda</code> 是如何让你把代码块作为参数传递给函数的人，但当你想当作参数传递的代码已经被定义成了函数，该怎么办？ <code>Kotlin</code> 跟 <code>Java 8</code> 一样，如果把函数转换成一个值，你就可以传递它，使用 <code>::</code> 运算符来转换：</p>
<pre><code>             // 类    //成员
val getAge = Person::age
</code></pre><p>这种表达式称为成员引用，它提供了简明语法，来创建一个调用单个方法或访问单个属性的函数值。双冒号把类名称与你要引用的成员(一个方法或一个属性)名称隔开。同样的内容用 <code>lambda</code> 表达式实现是这样的：</p>
<pre><code>val getAge = { p :Person -&gt; p.age}
</code></pre><p><strong>注意： 不管引用的是函数还是属性，都不要在成员引用的名称后面加括号。成员引用和调用该函数的 lambda 具有一样的类型，可以互换使用。</strong></p>
<p>还可以引用顶层函数(不是类的成员，直接写在文件的函数)：</p>
<pre><code>// 这是一个顶层函数
fun salute() = println(&quot;salute&quot;)
// 引用顶层函数作为实参传递给 run 函数
run(::salute)    // 省略了类名
</code></pre><p>如果 <code>lambda</code> 要委托给一个接收多个参数的函数，提供成员引用代替它将会非常方便:</p>
<pre><code>fun sendEmail(person: Person, message: String) {
}

// 有两个参数的 lambda
val action = {person: Person,message :String -&gt;
    // 委托给 sendEmail 函数
    sendEmail(person,message)
}

// 利用成员引用的方式，等价于前一个 action 
val nextAction = ::sendEmail
</code></pre><p>可以用构造方法引用存储或延期执行创建类实例的作用，构造方法引用的形式是在双冒号后指定类名称：</p>
<pre><code>fun printPerson() {
    // 创建 Person 实例的动作被保存成了值
    val createPerson = ::Person
    // 延期执行创建类实例
    val p = createPerson(&quot;fanda&quot;, 19)
    println(p)
}
</code></pre><p>还可以用同样的方式引用扩展函数：</p>
<pre><code>// 扩展函数
fun Person.isAdult() = age &gt;= 18
// 成员引用扩展函数
val predicate = Person::isAdult
predicate(person)
</code></pre><p>尽管 <code>isAdult</code> 不是 <code>Person</code> 类的成员，还是可以通过成员引用访问它，这和访问实例的成员没什么两样： <code>person.isAdult()</code> 。</p>
<p><strong>注意：无论是成员引用的属性还是函数，生成的都是一个函数值，使用的时候要用括号。</strong></p>
<h3 id="绑定引用"><a href="#绑定引用" class="headerlink" title="绑定引用"></a>绑定引用</h3><p>在 <code>Kotlin 1.0</code> 中，当接受一个类的方法或属性引用时，你始终需要提供一个该类的实例来调用这个引用。 <code>Kotlin 1.1</code> 计划支持绑定成员引用，它允许你使用成员引用语法捕获特定实例对象上的方法引用。</p>
<pre><code>// 创建 Person 实例的动作被保存成了值
val createPerson = ::Person
// 延期执行创建类实例
val p = createPerson(&quot;fanda&quot;, 19)

val predicate = Person::isAdult
// 提供一个该类的实例来调用，需要传入参数
println(predicate(p))

// 捕获特定实例对象上的方法引用
val predicate = p::isAdult
// 不用传入参数
println(predicate())
</code></pre><h2 id="集合的函数式-API"><a href="#集合的函数式-API" class="headerlink" title="集合的函数式 API"></a>集合的函数式 API</h2><p>函数式编程风格在操作集合时提供了很多优势，大多数任务都可以通过库函数完成，来简化你的代码。</p>
<h3 id="基础：-filter-和-map"><a href="#基础：-filter-和-map" class="headerlink" title="基础： filter 和 map"></a>基础： filter 和 map</h3><p><code>filter</code> 函数遍历集合并选出应用给定 <code>lambda</code> 后返回 <code>true</code> 的那些元素：</p>
<pre><code>val list = listOf(1, 2, 3, 4)
//输出 [2, 4]
println(list.filter { it % 2 == 0 })
</code></pre><p>返回的结果是一个新的集合，它只包含集合中那些满足判断的元素。如果你想留下那些超过 <code>30</code> 岁的人，可以用 <code>filter</code> 这样写：</p>
<pre><code>val personList = listOf(Person(&quot;fanda&quot;, 38), Person(&quot;liuhang&quot;, 22))
// 输出  [Person(name=fanda, age=38)]
println(personList.filter { it.age &gt; 30 })
</code></pre><p><code>map</code> 函数对集合中的每个元素应用给定的函数并把结果收集到一个新集合，可以把数字列表变换成它们平方的列表，比如：</p>
<pre><code>val list = listOf(1, 2, 3, 4)
// 输出 [1, 4, 9, 16]
println(list.map { it * it })
</code></pre><p>结果是一个新的集合，包含的元素的个数不变，但是每个元素根据给定的判断式做了变换处理。如果你想打印的只是一个姓名列表，而不是人的完整信息，可以用 <code>map</code> 来变换列表：</p>
<pre><code>val personList = listOf(Person(&quot;fanda&quot;, 38), Person(&quot;liuhang&quot;, 22))
// 输出  [fanda, liuhang]
println(personList.map { it.name })
// 成员引用的写法
println(personList.map(Person::name))
</code></pre><p>可以轻松地把多次这样的调用链接起来，例如，打印出年龄超过 <code>30</code> 岁的人的名字：</p>
<pre><code>// [fanda]
println(personList.filter { it.age &gt; 30 }.map { it.name })
</code></pre><p>现在，如果说需要这个分组中所有年龄最大的人的名字，可以先找到分组中人的最大年龄，然后返回所有这个年龄的人，很容易就用 <code>lambda</code> 写出如下代码：</p>
<pre><code>// !! 是让编译器不要判断元素是否为 null
println(personList.filter { it.age == personList.maxBy(Person::age)!!.age })
</code></pre><p>但是注意，这段代码对每个人都会重复寻找最大年龄的过程，假设集合中有 <code>100</code> 个人，寻找最大年龄的过程就会执行 <code>100</code> 遍！下面的解决方法做出了改进，只计算了一次最大年龄：</p>
<pre><code>val maxAge = personList.maxBy(Person::age)!!.age
println(personList.filter { it.age == maxAge})
</code></pre><p>如果没有必要就不要重复计算！使用 <code>lambda</code> 表达式的代码看起来简单，有时候却掩盖底层操作的复杂性。始终牢记你写的代码在干什么。</p>
<p>还可以对 <code>map</code> 集合应用过滤和变换函数：</p>
<pre><code>val numbers = mapOf(0 to &quot;zero&quot;, 1 to &quot;one&quot;)
// 变换值  {0=ZERO, 1=ONE}
println(numbers.mapValues { it.value.toUpperCase() })
// 过滤值  {0=zero}
println(numbers.filterValues { it.length &gt; 3 })

// 变换键  {1=zero, 2=one}
println(numbers.mapKeys { it.key + 1 })

// 过滤键  {1=one}
println(numbers.filterKeys { it &gt; 0 })
</code></pre><p>键和值分别由各自的函数来处理。 <code>filterKeys</code> 和 <code>mapKeys</code> 过滤和变换 <code>map</code> 集合的键，而另外的 <code>filterValues</code> 和 <code>mapValues</code> 过滤和变换对应的值。</p>
<h3 id="“all”-“any”-“count”和”find”：对集合应用判断式"><a href="#“all”-“any”-“count”和”find”：对集合应用判断式" class="headerlink" title="“all” “any” “count”和”find”：对集合应用判断式"></a>“all” “any” “count”和”find”：对集合应用判断式</h3><p>另一种常见的任务是检查集合中所有元素是否都符合某个条件（或者它的变种，是否存在符合的元素）。 <code>Kotlin</code> 中，它们是通过 <code>all</code> 和 <code>any</code> 函数表达的。 <code>count</code> 函数检查有多少元素满足判断式，而 <code>find</code> 函数返回第一个符合条件的元素。<br>为了演示这些函数，我们先来定义一个判断式，来检查一个人是否还没有到 <code>28</code> 岁：</p>
<pre><code>val canBeInClub27 = {p: Person -&gt; p.age &lt;= 27}
</code></pre><p>如果你对是否所有元素都满足判断式感兴趣，可以用 <code>all</code> 函数：</p>
<pre><code>val personList = listOf(Person(&quot;fanda&quot;, 38), Person(&quot;liuhang&quot;, 22))
println(personList.all(canBeInClub27))  // false
</code></pre><p>如果你要检查集合中是否至少存在一个匹配的元素，那就用 <code>any</code> 函数：</p>
<pre><code>val personList = listOf(Person(&quot;fanda&quot;, 38), Person(&quot;liuhang&quot;, 22))
println(personList.any(canBeInClub27))  // true
</code></pre><p><strong>注意： !all（不是所有）加上某个条件，可以用any加上这个条件的取反来替换，反之亦然。为了让你的代码更容易理解，应该选择前面不需要否定符号的函数。</strong></p>
<pre><code>val personList = listOf(Person(&quot;fanda&quot;, 38), Person(&quot;liuhang&quot;, 22))
// true
println(!personList.all { it.age == 22 })  // ! 否定不明显，最好用 any 替换
// true
println(personList.any { it.age != 22 })  // lambda 参数中的条件要取反
</code></pre><p>如果你想知道有多少个元素满足了判断式，就使用 <code>count</code> 函数：</p>
<pre><code>val personList = listOf(Person(&quot;fanda&quot;, 38), Person(&quot;liuhang&quot;, 22))
println(personList.count(canBeInClub27))  // 1
</code></pre><p><code>count</code> 函数很容易被遗忘，然后通过过滤集合之后再取大小来实现：</p>
<pre><code>val personList = listOf(Person(&quot;fanda&quot;, 38), Person(&quot;liuhang&quot;, 22))
println(personList.filter(canBeInClub27).size)  // 1
</code></pre><p>在这种情况下，一个中间集合会被创建并用来存储所有满足判断式的元素。而另一方面，<code>count</code> 方法只是跟踪匹配元素的数量，不关心元素本身，所以更高效。</p>
<p>要找到一个满足判断式的元素，使用 <code>find</code> 函数 ：</p>
<pre><code>val personList = listOf(Person(&quot;fanda&quot;, 38), Person(&quot;liuhang&quot;, 22))
println(personList.find(canBeInClub27))  // Person(name=liuhang, age=22)
</code></pre><p>如果有多个匹配的元素，就返回其中第一个元素，没有匹配的元素则返回 <code>null</code> 。 <code>find</code> 还有一个同义方法 <code>firstOrNull</code> ，可以使用这个方法更清楚地表达你的意图。</p>
<h3 id="groupBy-把列表转换成分组的-map"><a href="#groupBy-把列表转换成分组的-map" class="headerlink" title="groupBy: 把列表转换成分组的 map"></a>groupBy: 把列表转换成分组的 map</h3><p>假设你需要把所有元素按照不同的特征划分成不同的分组。例如，你想把人按年龄分组，相同的年龄的人在一组。把这个特征直接当做参数传递十分方便。 <code>groupBy</code> 函数可以帮你做到这一点：</p>
<pre><code>val personList = listOf(Person(&quot;fanda&quot;, 38), Person(&quot;liuhang&quot;, 22), Person(&quot;dudu&quot;, 22))

println(personList.groupBy { it.age })

// 输出 {38=[Person(name=fanda, age=38)], 22=[Person(name=liuhang, age=22), Person(name=dudu, age=22)]}
</code></pre><p>结果是一个 <code>map</code> ，是元素分组依据的键(上述例子是 <code>age</code>) 和元素分组 (<code>persons</code>) 之间的映射。每一个分组都存在一个列表中，上述例子的结果的类型其实就是<code>Map&lt;Int，List&lt;Person&gt;&gt;</code> 。还可以使用像 <code>mapKeys</code> 和 <code>mapValues</code> 这样的函数对这个 <code>map</code> 做进一步修改。比如：</p>
<pre><code>println(personList.groupBy { it.age }.mapValues {
    it.value.joinToString { p: Person -&gt; p.name }
})

// 输出 {38=fanda, 22=liuhang, dudu}
</code></pre><p>我们再来看另外一个例子，如何使用成员引用把字符串按照首字母分组：</p>
<pre><code>val list = listOf(&quot;a&quot;, &quot;ab&quot;, &quot;dad&quot;, &quot;rs&quot;)
// {a=[a, ab], d=[dad], r=[rs]}
println(list.groupBy(String::first))
</code></pre><p>这里的 <code>first</code> 并不是 <code>String</code> 类的成员，而是一个扩展，也可以把它当做成员引用访问。</p>
<h3 id="flatMap-和-flatten-：处理嵌套集合中的元素"><a href="#flatMap-和-flatten-：处理嵌套集合中的元素" class="headerlink" title="flatMap 和 flatten ：处理嵌套集合中的元素"></a>flatMap 和 flatten ：处理嵌套集合中的元素</h3><p><code>flatMap</code> 函数做了两件事：首先根据作为实参给定的函数对集合中单个元素做变换，然后把多个列表平铺成一个列表，示例如下：</p>
<pre><code>data class Book(val title: String, val authors: List&lt;String&gt;)

val books = listOf(
    Book(&quot;a&quot;, listOf(&quot;aaa1&quot;, &quot;aaa2&quot;)),
    Book(&quot;b&quot;, listOf(&quot;bbb1&quot;, &quot;bbb2&quot;)),
    Book(&quot;c&quot;, listOf(&quot;ccc1&quot;, &quot;ccc2&quot;)),
    Book(&quot;d&quot;, listOf(&quot;aaa1&quot;, &quot;aaa2&quot;))
)

// 只做了变换操作，[[aaa1, aaa2], [bbb1, bbb2], [ccc1, ccc2], [aaa1, aaa2]]
println(books.map { it.authors })
// 做了变换且平铺 [aaa1, aaa2, bbb1, bbb2, ccc1, ccc2, aaa1, aaa2]
println(books.flatMap { it.authors })
// 平铺且去重 [aaa1, aaa2, bbb1, bbb2, ccc1, ccc2]
println(books.flatMap { it.authors }.toSet())
</code></pre><p><code>flatMap</code> 函数做了 <code>map</code> 的变换且还执行了平铺操作，<code>toSet</code> 函数是转换成 <code>set</code> 来进行去重处理了。</p>
<p>当你卡壳在元素<strong>集合的集合</strong>不得不合并成一个的时候，可以用 <code>flapMap</code> 来处理。如果你不需要做任何变换，只是需要平铺一个集合，可以使用 <code>flatten</code> 函数：</p>
<pre><code>val list = listOf(listOf(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;), listOf(&quot;111&quot;, &quot;222&quot;), listOf(1, 2, 3))
// [aaa, bbb, ccc, 111, 222, 1, 2, 3]
println(list.flatten())
</code></pre><p><code>flatten</code> 函数只作用在集合的集合中，没有变换处理，结果会平铺成一个列表。</p>
<h2 id="惰性集合操作：序列"><a href="#惰性集合操作：序列" class="headerlink" title="惰性集合操作：序列"></a>惰性集合操作：序列</h2><p>先来看个例子：</p>
<pre><code>val personList = listOf(Person(&quot;fanda&quot;, 38), Person(&quot;liuhang&quot;, 22), Person(&quot;dudu&quot;, 22))
val newList = personList.map(Person::name).filter { it.startsWith(&quot;f&quot;) }
println(newList)
</code></pre><p><code>filter</code> 和 <code>map</code> 都会返回一个列表。这意味着上面例子中的链式调用会创建两个列表：一个保存 <code>filter</code> 函数的结果，另一个保存 <code>map</code> 函数的结果。如果原列表只有两个元素，这不是什么问题，但是如果有一百万个元素，链式调用就会变得十分低效。</p>
<p>为了提高效率，可以把操作变成使用序列，而不是直接使用集合：</p>
<pre><code>val sequenceList =personList.asSequence()       // 把初始集合转换成序列
    .map(Person::name).filter { it.startsWith(&quot;f&quot;) }
    .toList()   // 把结果序列转换回列表
</code></pre><p>序列没有创建任何用于存储元素的中间集合，所以元素数量巨大的情况下性能将显著提升。可以调用扩展函数 <code>asSequence</code> 把任意集合转换成序列,调用 <code>toList</code> 来做反向的转换。因为序列的操作是惰性的，为了执行它们，你需要直接迭代序列元素，或者把序列转换成一个集合。</p>
<p><strong>注意： 需要对一个大型集合执行链式操作时使用序列才有优势，通常都不需要使用序列。</strong></p>
<h3 id="执行序列操作：中间和末端操作"><a href="#执行序列操作：中间和末端操作" class="headerlink" title="执行序列操作：中间和末端操作"></a>执行序列操作：中间和末端操作</h3><p>序列操作分为两类：中间的和末端的。一次中间操作返回的是另一个序列，这个新序列知道如何变换原始序列中的元素。而一次末端操作返回的是一个结果，这个结果可能是集合、元素、数字，或者其他从初始集合的变换序列中获取的任意对象。</p>
<pre><code>                    //中间操作         //末端操作
personList.asSequence().map{..}.filter {..}.toList() 
</code></pre><p>中间操作始终都是惰性的。先看看下面这个缺少了末端操作的例子：</p>
<pre><code>listOf(1, 2, 3, 4).asSequence()
    .map { print(&quot;map($it) &quot;); it * it }
    .filter {
        print(&quot;filter($it) &quot;); it % 2 == 0
    }
</code></pre><p><strong>注意： lambda 多行代码写在同一行时，要用 ； 分隔开，最后的代码才是结果，不然就写成多行的。</strong></p>
<pre><code>listOf(1, 2, 3, 4).asSequence().map {
    // 写成多行
    print(&quot;map($it) &quot;)
    it * it
}.filter {
    print(&quot;filter($it) &quot;)
    it % 2 == 0
}
</code></pre><p>执行这段代码并不会再控制台上输出任何内容。这意味着 <code>map</code> 和 <code>filter</code> 变换被延期了，它们只有在获取结果的时候才会被应用（即末端操作调用的时候）：</p>
<pre><code>listOf(1, 2, 3, 4).asSequence()
    // 写在一行，要有分号 ；
    .map { print(&quot;map($it) &quot;); it * it }
    .filter {
        print(&quot;filter($it) &quot;); it % 2 == 0
    }.toList()  // 末端操作

// 输出 
map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16) 
</code></pre><p>末端操作触发执行了所有的延期计算。<br>这个例子中另外一件值得注意的事情是计算执行的顺序。一个笨办法是现在每个元素上调用 <code>map</code> 函数，然后在结果序列的每个元素上在调用 <code>filter</code> 函数。 <code>map</code> 和 <code>filter</code> 对集合就是这样做的，而序列不一样。对序列来说，所有操作是按顺序应用在每一个元素上的，处理完第一个元素（先映射在过滤），然后完成第二个元素的处理，以此类推。这种方法意味着部分元素根本不会发生任何变换，如果在轮到它们之前就已经取得了结果。</p>
<h3 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h3><p>前面的列表都是使用同一个方法创建序列：在集合上调用 <code>asSquence()</code> 。另一个可能性是使用 <code>generateSequence</code> 函数。给定序列中的前一个元素，这个函数会计算出下一个元素。下面这个例子就是如何使用 <code>generateSequence</code> 计算 <code>100</code> 以内所有自然数之和。</p>
<pre><code>val numbers = generateSequence(0){ it + 1}  // 生成一个序列
val numbersTo100 = numbers.takeWhile { it &lt;= 100 }  // 中间操作，生成另一个序列
println(numbersTo100.sum()) // 末端操作，执行所有被推迟的操作，得到结果
</code></pre><p><strong>注意：这个例子中的 numbers 和 numbersTo100 都是有延期操作的序列。这些序列中的实际数字直到你调用末端操作（这里是sum）的时候才会求值。</strong></p>
<p>另一种常见的用例是父序列。如果元素的父元素和它的类型相同（比如人类或者Java文件），你可能会对它所有祖先组成的序列的特质感兴趣。下面这个例子可以查询文件是否放在隐藏目录中，通过创建一个其父类目录的序列并检查每个目录的属性来实现。</p>
<pre><code>fun File.isInsideHiddenDirectory() =
    generateSequence(this) { it.parentFile }.any { it.isHidden }

val file = File(&quot;/Users/svtk/.HiddenDir/a.txt&quot;)
println(file.isInsideHiddenDirectory())
</code></pre><p>你生成一个序列，通过<strong>提供第一个元素</strong>和<strong>获取每个后续元素</strong>的方式来实现。如果把 <code>any</code> 换成 <code>find</code> ，你还可以得到想要的那个目录（对象）。注意，<strong>使用序列允许你找到需要的目录之后立即停止遍历目录</strong>。</p>
<h2 id="使用-Java-函数式接口"><a href="#使用-Java-函数式接口" class="headerlink" title="使用 Java 函数式接口"></a>使用 Java 函数式接口</h2><p><code>Kotlin</code> 的 <code>lambda</code> 也可以无缝地和 <code>Java API</code> 互操作。在文章开头，我们就把 <code>lambda</code> 传给 <code>Java</code> 方法的例子：</p>
<pre><code>/* Kotlin */
button.setOnClickListener{ /* do someting */ }
</code></pre><p><code>Button</code> 类通过接收类型为 <code>OnClickListner</code> 的实参的 <code>setOnClickListener</code> 方法给按钮设置一个新的监听器，在<code>Java 8</code> 之前中我们不得不创建一个匿名类来作为实参传递：</p>
<pre><code>/* Java */
button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            //do something
        }
});
</code></pre><p>在 <code>Kotlin</code> 中，可以传递一个 <code>lambda</code> ，代替这个例子：</p>
<pre><code>/* Kotlin */
button.setOnClickListener{ view -&gt; ... }
</code></pre><p>这种方法可以工作的原因是 <code>OnClickListener</code> 接口只有一个抽象方法，这种接口被称为函数式接口或者 <code>SAM</code> 接口(单抽象方法接口)，<code>Java API</code> 中随处可见像 <code>Runnable</code> 和 <code>Callable</code> 这样的函数式接口，以及支持它们的方法。 <code>Kotlin</code> 允许你在调用接收函数式接口作为参数的方法时使用 <code>lambda</code> ，来保证你的 <code>Kotlin</code> 代码即整洁又符合习惯。</p>
<h3 id="把lambda当做参数传递给Java方法"><a href="#把lambda当做参数传递给Java方法" class="headerlink" title="把lambda当做参数传递给Java方法"></a>把lambda当做参数传递给Java方法</h3><p>可以把 <code>lambda</code> 传给任何期望函数式接口的方法。例如下面这个方法，它有一个 <code>Runnable</code> 类型的参数：</p>
<pre><code>// java
public static void postponeCoputation(int delay, Runnable computation) {
    computation.run();
}
</code></pre><p>在 <code>Kotlin</code> 中，可以调用它并把一个 <code>lambda</code> 作为实参传给它，编译器会自动把它转换成一个 <code>Runnable</code> 实例：</p>
<pre><code>LambdaPraticeJava.postponeCoputation(1000) { println(42) }
</code></pre><p>当我们说一个 <code>Runnable</code> 的实例时，指的是一个实现了 <code>Runnable</code> 接口的匿名内部类的实例，编译器会帮你创建它，并使用 <code>lambda</code> 作为单抽象方法的方法体。</p>
<p>通过显式的创建一个实现了 <code>Runnable</code> 的匿名对象也能达到同样的效果：</p>
<pre><code>LambdaPraticeJava.postponeCoputation(1000, object : Runnable {
    override fun run() {
        // 这里打印 hashCode
        println(this.hashCode())
    }
})
</code></pre><p>这里打印的是匿名内部类的 <code>hashCode</code> ，通过 <code>this</code> 来引用该类，上述没有显式创建对象的 <code>lambda</code> 是引用不了 <code>this</code> 的。</p>
<p>注意：当你显式地声明对象时，每次调用都会创建一个新的实例。而如果 <code>lambda</code> 没有访问任何来自定义它的函数的变量，相应的匿名类实例可以在多次调用之间重用。</p>
<p>因此完全等价的实现应该是下面这段代码中显示 <code>object</code> 声明，它把 <code>Runnable</code> 实例存储在一个变量中，并且每次调用的时候都使用这个变量：</p>
<pre><code>val runnable = object : Runnable {
    override fun run() {
        println( this.hashCode())
    }
}
</code></pre><p>测试用例：</p>
<pre><code>fun testLabdaMethod2() {
    for (count in 1..3) {
        LambdaPraticeJava.postponeCoputation(1000, object : Runnable {
            override fun run() {
                println(this.hashCode())
            }
        })
    }

    println()

    for (count in 1..3) {
        // 每次调用的时候都使用这个变量
        LambdaPraticeJava.postponeCoputation(1000, runnable)
        // 等价于这种形式调用
        LambdaPraticeJava.postponeCoputation(1000) { ... }
    }
}
</code></pre><p>输出：</p>
<pre><code>1392838282
523429237
664740647

// 数值一样，证明相应的匿名类实例在多次调用之间重用
testValue804564176
testValue804564176
testValue804564176
</code></pre><p><strong>注意： 如果 lambda 从包围它的作用域中捕获了变量，每次调用就不再可能重用一同一个实例了。这种情况下，每次调用时编译器都要创建一个新对象，其中存储着被捕获的变量的值。</strong></p>
<h3 id="SAM-构造方法：显式地把-lambda-转换成函数式接口"><a href="#SAM-构造方法：显式地把-lambda-转换成函数式接口" class="headerlink" title="SAM 构造方法：显式地把 lambda 转换成函数式接口"></a>SAM 构造方法：显式地把 lambda 转换成函数式接口</h3><p><code>SAM</code> 构造方法是编译器自动生成的函数，让你执行从 <code>lambda</code> 到函数式接口实例的显式转换。例如，如果有一个方法返回的是一个函数式接口的实例，不能直接返回一个 <code>lambda</code> ，要用 <code>SAM</code> 构造方法把它包起来：</p>
<pre><code>fun createRunnable() = Runnable { println(&quot;Create Success&quot;) }

createRunnable().run()
</code></pre><p><strong>SAM 构造方法的名称和底层函数式接口的名称一样，参数只有一个(被用作函数式接口单抽象方法体的 lambda )，返回的是这个接口类的一个实例。</strong></p>
<p>除了返回值外，<code>SAM</code> 构造方法还可以用在需要把从 <code>lambda</code> 生成的函数式接口实例存储在一个变量中的情况。假设你要在多个按钮上重用同一个监听器，就像下面的代码一样：</p>
<pre><code>val listener = View.OnClickListener{ view -&gt;
    val text = when (view.id) {
        R.id.button_1 -&gt; &quot;First Button&quot;
        R.id.button_2 -&gt; &quot;Second Button&quot;
        else -&gt; &quot;Unknown Button&quot;
    }
    println(text)
}

firstButton.setOnClickListener(listener)
secondButton.setOnClickListener(listener)
</code></pre><p>其实也可以用对象表达式来创建实例，但是 <code>SAM</code> 构造方法更简洁。</p>
<p>注意: <code>lambda</code> 内部没有匿名对象那样的 <code>this</code> ，即没有办法引用到 <code>lambda</code> 转换成的匿名类实例。从编译器的角度来看，<code>lambda</code> 是一个代码块，不是一个对象，而且也不能把它当成对象引用。 <code>lambda</code> 中的 <code>this</code> 指向的是包围它的类。如果你的事件监听器在处理事件时还需要取消它自己，不能使用 <code>lambda</code> 这样做。这种情况使用实现了接口的匿名对象，在匿名对象内，<code>this</code> 关键字指向该对象实例，可以把它传给移除监听器的 <code>API</code> 。</p>
<h2 id="带接收者的-lambda-with-与-apply"><a href="#带接收者的-lambda-with-与-apply" class="headerlink" title="带接收者的 lambda : with 与 apply"></a>带接收者的 lambda : with 与 apply</h2><h3 id="with-函数"><a href="#with-函数" class="headerlink" title="with 函数"></a>with 函数</h3><p>可以用 <code>with</code> 函数对同一个对象执行多次操作，而不需要反复把对象的名称写出来，我们先看一个不用 <code>with</code> 函数的例子：</p>
<pre><code>fun testNoWithMethod(): String {
    val result = StringBuilder()
    for (letter in &apos;A&apos;..&apos;Z&apos;) {
        result.append(letter)
    }
    result.append(&quot;\nEnd&quot;)
    return result.toString()
}
</code></pre><p>上述的例子中，调用了 <code>result</code> 实例的好几个方法，而且每次调用都要重复 <code>result</code> 这个名称，很麻烦且不简洁，用 <code>with</code> 函数重写后是这样的：</p>
<pre><code>fun testWithMehtod() =
        with(StringBuilder()){
            for (letter in &apos;A&apos;..&apos;Z&apos;) {
                this.append(letter)    // 显式调用 this
            }
            append(&quot;\nEnd&quot;)    // 省略 this
            toString()    // 从 lambda 返回值
        }
</code></pre><p>现在这个函数只返回一个表达式，所以使用表达式函数体语法重写了它。</p>
<p><code>with</code> 函数实际上是一个接收两个参数的函数：这个例子中两个参数分别是 <code>stringBuilder</code> 和一个 <code>lambda</code> 。这里利用了把 <code>lambda</code> 放在括号外的约定，这样整个调用看起来就像是内建的语言功能，当然你也可以选择把它写成 <code>with(stringBuilder, {...})</code> 。 <code>with</code> 函数把它的第一个参数转换成第二个参数传给他的 <code>lambda</code> 的接收者。可以显式地通过 <code>this</code> 引用来访问这个接收者，或者可以省略 <code>this</code> 引用。<br><code>with</code> 返回的值是执行 <code>lambda</code> 代码的结果，该结果就是 <code>lambda</code> 中的最后一个表达式（的值）。</p>
<p>可以使用标准库函数 <code>buildString</code> 进一步简函数 ：</p>
<pre><code>fun testBuildString() = buildString {
    for (letter in &apos;A&apos;..&apos;Z&apos;) {
        append(letter)
    }
    append(&quot;\nEnd&quot;)
}
</code></pre><p>它会负责创建 <code>StringBuilder</code> 并调用 <code>toString</code>，源码是这样的：</p>
<pre><code>public inline fun buildString(builderAction: StringBuilder.() -&gt; Unit): String =
    StringBuilder().apply(builderAction).toString()
</code></pre><p><strong>注意：在扩展函数体内部，this指向了这个函数的那个类型的实例，而且也可以被省略掉，让你直接访问接收者的成员。一个扩展函数某种意义上来说就是带接收者的函数。</strong></p>
<p><strong>注意： 如果使用 with 的类的方法名和外部的对象的名称一样，可以使用 this@OuterClass 这样的语法来引用外部类的方法。</strong></p>
<h3 id="apply-函数"><a href="#apply-函数" class="headerlink" title="apply 函数"></a>apply 函数</h3><p><code>apply</code> 函数跟 <code>with</code> 函数的唯一区别是始终会返回作为实参传递给它的接收者对象，让我们用 <code>apply</code> 来重构上述的方法：</p>
<pre><code>fun testApplyMethod() =
    StringBuilder().apply {
        for (letter in &apos;A&apos;..&apos;Z&apos;) {
            append(letter)
        }
        append(&quot;\nEnd&quot;)
    }.toString()
</code></pre><p>在创建一个对象实例需要用正确的方式初始化它的一些属性的时候。在 <code>Java</code> 中，这通常是通过另外一个单独的 <code>Builder</code> 对象来完成的，而在 <code>Kotlin</code> 中，可以在任意对象上使用 <code>apply</code> ，完全不需要任何任何来自定义该对象的库的特别支持。</p>
<p>我们来用 <code>apply</code> 演示一个 <code>Android</code> 中创建 <code>TextView</code> 实例的例子：</p>
<pre><code>fun createViewWithCustomAttr(context: Context) =
    TextView(context).apply {
        text = &quot;simple text&quot;
        textSize = 19f
        setPadding(0, 10, 0, 10)
    }
</code></pre><p><code>Lambda</code> 执行之后，<code>apply</code> 返回已经初始化过的接收者实例，它变成了 <code>createViewWithCustomAttr</code> 函数的结果。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>lambda</code> 允许你把代码块当作参数传递给函数。</li>
<li><code>kotlin</code> 可以把 <code>lambda</code> 放在括号外传递给函数，而且可以用 <code>it</code> 引用单个 <code>lambda</code> 参数。</li>
<li><code>lambda</code> 中的代码可以访问和修改包含这个 <code>lambda</code> 调用的函数中的变量。</li>
<li>通过在函数名称前加上前缀 <code>::</code> ，可以创建方法、构造方法及属性的引用，并用这些引用代替 <code>lambda</code> 传递给函数。</li>
<li>使用像 <code>filter</code>、 <code>map</code>、 <code>all</code>、 <code>any</code> 等函数，大多数公共的集合操作不需要手动迭代元素就可以完成。</li>
<li>序列允许你合并一个集合上的多次操作，而不需要创建新的集合来保存中间结果。</li>
<li>可以把 <code>lambda</code> 作为实参传给接收 <code>java</code> 函数式接口(带单抽象方法的接口，也叫作 <code>SAM</code> 接口)作为形参的方法。</li>
<li>带接收者的 <code>lambda</code> 是一种特殊的 <code>lambda</code> ，可以在这种 <code>lambda</code> 中直接访问一个特殊接收者对象的方法。</li>
<li><code>with</code> 函数允许你调用一个对象的多个方法，而不需要反复写出这个对象的引用。</li>
<li><code>apply</code> 函数让你使用构建者风格的 <code>API</code> 创建和初始化任何对象。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kotlin/" rel="tag"><i class="fa fa-tag"></i> kotlin</a>
          
            <a href="/tags/Lambda/" rel="tag"><i class="fa fa-tag"></i> Lambda</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/14/kotlin/KotlinClass/" rel="next" title="类、对象和接口">
                <i class="fa fa-chevron-left"></i> 类、对象和接口
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/29/kotlin/KotlinNullable/" rel="prev" title="Kotlin 的可空性">
                Kotlin 的可空性 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
	  <div id="gitalk-container"></div>   
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/images/avatar.jpg" alt="Fanda">
          <p class="site-author-name" itemprop="name">Fanda</p>
           
              <p class="site-description motion-element" itemprop="description">IT相关技术</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">80</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fandazeng" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/fandazeng" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/fandazeng" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-group"></i>
                  
                  掘金
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/fandazeng" target="_blank" title="JianShu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  JianShu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda-表达式和成员引用"><span class="nav-number">1.</span> <span class="nav-text">Lambda 表达式和成员引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-简介：-作为函数参数的代码块"><span class="nav-number">1.1.</span> <span class="nav-text">Lambda 简介： 作为函数参数的代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-和集合"><span class="nav-number">1.2.</span> <span class="nav-text">Lambda 和集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-表达式的语法"><span class="nav-number">1.3.</span> <span class="nav-text">Lambda 表达式的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在作用域中访问变量"><span class="nav-number">1.4.</span> <span class="nav-text">在作用域中访问变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员引用"><span class="nav-number">1.5.</span> <span class="nav-text">成员引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定引用"><span class="nav-number">1.6.</span> <span class="nav-text">绑定引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合的函数式-API"><span class="nav-number">2.</span> <span class="nav-text">集合的函数式 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础：-filter-和-map"><span class="nav-number">2.1.</span> <span class="nav-text">基础： filter 和 map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“all”-“any”-“count”和”find”：对集合应用判断式"><span class="nav-number">2.2.</span> <span class="nav-text">“all” “any” “count”和”find”：对集合应用判断式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#groupBy-把列表转换成分组的-map"><span class="nav-number">2.3.</span> <span class="nav-text">groupBy: 把列表转换成分组的 map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flatMap-和-flatten-：处理嵌套集合中的元素"><span class="nav-number">2.4.</span> <span class="nav-text">flatMap 和 flatten ：处理嵌套集合中的元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#惰性集合操作：序列"><span class="nav-number">3.</span> <span class="nav-text">惰性集合操作：序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#执行序列操作：中间和末端操作"><span class="nav-number">3.1.</span> <span class="nav-text">执行序列操作：中间和末端操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建序列"><span class="nav-number">3.2.</span> <span class="nav-text">创建序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Java-函数式接口"><span class="nav-number">4.</span> <span class="nav-text">使用 Java 函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#把lambda当做参数传递给Java方法"><span class="nav-number">4.1.</span> <span class="nav-text">把lambda当做参数传递给Java方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SAM-构造方法：显式地把-lambda-转换成函数式接口"><span class="nav-number">4.2.</span> <span class="nav-text">SAM 构造方法：显式地把 lambda 转换成函数式接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带接收者的-lambda-with-与-apply"><span class="nav-number">5.</span> <span class="nav-text">带接收者的 lambda : with 与 apply</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#with-函数"><span class="nav-number">5.1.</span> <span class="nav-text">with 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply-函数"><span class="nav-number">5.2.</span> <span class="nav-text">apply 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
	
	<div id="music163player">
		<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66"></iframe>
	</div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-Fanda"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fanda</span>
</div>

<div>
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style="display:none">
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style="display:none">
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>




        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/canvasline.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/baidu_tools.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>


  


  




	





  





  





  






  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '0a24ec23db863f69c94e',
          clientSecret: '454d8ed43ceaa65490b7a854f7cef0b95b7e3be6',
          repo: 'fandazeng.github.io',
          owner: 'fandazeng',
          admin: ['fandazeng'],
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>

  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("eROyoFH3H91PrCEieToSBnny-gzGzoHsz", "D5CAVRJl32bxjAlfHhdpWlAA");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  


</body>
</html>